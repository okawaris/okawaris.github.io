<!DOCTYPE html><html lang="zh-tw"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Jia Xufeng"><meta name="copyright" content="Jia Xufeng"><title>向暗夜致敬 | 暗夜精灵のBlog</title><link rel="shortcut icon" href="http://image.icool8.cn/blog/20200618/tlIPrUJYHhnI.png?imageslim"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 5.3.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="http://image.icool8.cn/blog/20200618/tlIPrUJYHhnI.png?imageslim"></div><div class="author-info__name text-center">Jia Xufeng</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">85</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">83</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">29</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">暗夜精灵のBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">暗夜精灵のBlog</div><div id="site-sub-title">向暗夜致敬</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2017/12/17/Blog/java/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/">事务隔离级别</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-12-17</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/">事务隔离级别</a></span><div class="content"><h2 id="事务隔离级别-图文详解"><a href="#事务隔离级别-图文详解" class="headerlink" title="事务隔离级别(图文详解)"></a>事务隔离级别(图文详解)</h2><h3 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务?"></a>什么是事务?</h3><p>事务是逻辑上的一组操作，要么都执行，要么都不执行。</p>
<p>事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p>
<h3 id="事务的特性-ACID"><a href="#事务的特性-ACID" class="headerlink" title="事务的特性(ACID)"></a>事务的特性(ACID)</h3><p><img src="http://image.icool8.cn/blog/20201205/OFWQJfxc6Ppf.png?imageslim" alt="mark"></p>
<ol>
<li><strong>原子性：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li><strong>一致性：</strong> 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li>
<li><strong>隔离性：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li><strong>持久性：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
</ol>
<h3 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h3><p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对统一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</p>
<ul>
<li><strong>脏读（Dirty read）:</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</li>
<li><strong>丢失修改（Lost to modify）:</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。</li>
<li><strong>不可重复读（Unrepeatableread）:</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</li>
<li><strong>幻读（Phantom read）:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li>
</ul>
<p><strong>不可重复度和幻读区别：</strong></p>
<p>不可重复读的重点是修改，幻读的重点在于新增或者删除。</p>
<p>例1（同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 ）：事务1中的A先生读取自己的工资为 1000的操作还没完成，事务2中的B先生就修改了A的工资为2000，导 致A再读自己的工资时工资变为 2000；这就是不可重复读。</p>
<p>例2（同样的条件, 第1次和第2次读出来的记录数不一样 ）：假某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，共查到4条记录，这时事务2 又插入了一条工资大于3000的记录，事务1再次读取时查到的记录就变为了5条，这样就导致了幻读。</p>
<h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p><strong>SQL 标准定义了四个隔离级别：</strong></p>
<ul>
<li><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</li>
<li><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</li>
<li><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</li>
<li><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</li>
</ul>
<hr>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻影读</th>
</tr>
</thead>
<tbody><tr>
<td>READ-UNCOMMITTED</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>READ-COMMITTED</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>REPEATABLE-READ</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。我们可以通过<code>SELECT @@tx_isolation;</code>命令来查看,MySQL 8.0 该命令改为<code>SELECT @@transaction_isolation;</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT @@tx_isolation;</span><br><span class="line">+-----------------+</span><br><span class="line">| @@tx_isolation  |</span><br><span class="line">+-----------------+</span><br><span class="line">| REPEATABLE-READ |</span><br><span class="line">+-----------------+</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是：与 SQL 标准不同的地方在于InnoDB 存储引擎在 <strong>REPEATABLE-READ（可重读）</strong> 事务隔离级别下，允许应用使用 Next-Key Lock 锁算法来避免幻读的产生。这与其他数据库系统(如 SQL Server)是不同的。所以说虽然 InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>，但是可以通过应用加锁读（例如 <code>select * from table for update</code> 语句）来保证不会产生幻读，而这个加锁度使用到的机制就是 Next-Key Lock 锁算法。从而达到了 SQL 标准的 <strong>SERIALIZABLE(可串行化)</strong> 隔离级别。</p>
<p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是<strong>READ-COMMITTED(读取提交内容):**，但是你要知道的是InnoDB 存储引擎默认使用 **REPEATABLE-READ（可重读）</strong>并不会有任何性能损失。</p>
<p>InnoDB 存储引擎在 <strong>分布式事务</strong> 的情况下一般会用到**SERIALIZABLE(可串行化)**隔离级别。</p>
<h3 id="实际情况演示"><a href="#实际情况演示" class="headerlink" title="实际情况演示"></a>实际情况演示</h3><p>在下面我会使用 2 个命令行mysql ，模拟多线程（多事务）对同一份数据的脏读问题。</p>
<p>MySQL 命令行的默认配置中事务都是自动提交的，即执行SQL语句后就会马上执行 COMMIT 操作。如果要显式地开启一个事务需要使用命令：<code>START TARNSACTION</code>。</p>
<p>我们可以通过下面的命令来设置隔离级别。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET [SESSION|GLOBAL] TRANSACTION ISOLATION LEVEL [READ UNCOMMITTED|READ COMMITTED|REPEATABLE READ|SERIALIZABLE]</span><br></pre></td></tr></table></figure>
<p>我们再来看一下我们在下面实际操作中使用到的一些并发控制语句:</p>
<ul>
<li><code>START TARNSACTION</code> |<code>BEGIN</code>：显式地开启一个事务。</li>
<li><code>COMMIT</code>：提交事务，使得对数据库做的所有修改成为永久性。</li>
<li><code>ROLLBACK</code>：回滚会结束用户的事务，并撤销正在进行的所有未提交的修改。</li>
</ul>
<h4 id="脏读-读未提交"><a href="#脏读-读未提交" class="headerlink" title="脏读(读未提交)"></a>脏读(读未提交)</h4><p><img src="http://image.icool8.cn/blog/20201205/MXgkvXeS8owh.png?imageslim" alt="mark"></p>
<h4 id="避免脏读-读已提交"><a href="#避免脏读-读已提交" class="headerlink" title="避免脏读(读已提交)"></a>避免脏读(读已提交)</h4><p><img src="http://image.icool8.cn/blog/20201205/DU4DtmtAbxR5.png?imageslim" alt="mark"></p>
<h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><p>还是刚才上面的读已提交的图，虽然避免了读未提交，但是却出现了，一个事务还没有结束，就发生了 不可重复读问题。</p>
<p><img src="http://image.icool8.cn/blog/20201205/FT5IuEnMXrAm.png?imageslim" alt="mark"></p>
<h4 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h4><p><img src="http://image.icool8.cn/blog/20201205/wKDt8EGLA6SM.png?imageslim" alt="mark"></p>
<h4 id="防止幻读-可重复读"><a href="#防止幻读-可重复读" class="headerlink" title="防止幻读(可重复读)"></a>防止幻读(可重复读)</h4><p><img src="http://image.icool8.cn/blog/20201205/2mlzwjFamzX1.png?imageslim" alt="mark"></p>
<p>一个事务对数据库进行操作，这种操作的范围是数据库的全部行，然后第二个事务也在对这个数据库操作，这种操作可以是插入一行记录或删除一行记录，那么第一个是事务就会觉得自己出现了幻觉，怎么还有没有处理的记录呢? 或者 怎么多处理了一行记录呢?</p>
<p>幻读和不可重复读有些相似之处 ，但是不可重复读的重点是修改，幻读的重点在于新增或者删除。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2017/11/28/Blog/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql-%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87-%E9%9B%86%E7%BE%A4/">mysql-性能提升-集群</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-11-28</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/">mysql</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/mysql/">mysql</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87/">性能提升</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E9%9B%86%E7%BE%A4/">集群</a></span><div class="content"><h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><blockquote>
<p>横向扩展：从根本上（单机的硬件处理能力有限）提升数据库性能 。由此而生的相关技术：==读写分离、负载均衡==</p>
</blockquote>
<h2 id="安装和配置主从复制"><a href="#安装和配置主从复制" class="headerlink" title="安装和配置主从复制"></a>安装和配置主从复制</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul>
<li><code>Red Hat Enterprise Linux Server release 7.0 (Maipo)</code>（虚拟机）</li>
<li><code>mysql5.7</code>（<a target="_blank" rel="noopener" href="https://mirrors.163.com/mysql/Downloads/MySQL-5.7/mysql-5.7.23-linux-glibc2.12-x86_64.tar.gz">下载地址</a>）</li>
</ul>
<h3 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h3><p>解压到对外提供的服务的目录（我自己专门创建了一个<code>/export/server</code>来存放）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar xzvf mysql-5.7.23-linux-glibc2.12-x86_64.tar.gz -C &#x2F;export&#x2F;server</span><br><span class="line">cd &#x2F;export&#x2F;server</span><br><span class="line">mv mysql-5.7.23-linux-glibc2.12-x86_64 mysql</span><br></pre></td></tr></table></figure></div><a class="more" href="/2017/11/28/Blog/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql-%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87-%E9%9B%86%E7%BE%A4/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2017/11/23/Blog/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql-%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87-%E5%88%86%E5%8C%BA/">mysql-性能提升-分区</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-11-23</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/">mysql</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/mysql/">mysql</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E5%88%86%E5%8C%BA/">分区</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87/">性能提升</a></span><div class="content"><h1 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h1><p>一般情况下我们创建的表对应一组存储文件，使用<code>MyISAM</code>存储引擎时是一个<code>.MYI</code>和<code>.MYD</code>文件，使用<code>Innodb</code>存储引擎时是一个<code>.ibd</code>和<code>.frm</code>（表结构）文件。</p>
<p>当数据量较大时（一般千万条记录级别以上），MySQL的性能就会开始下降，这时我们就需要将数据分散到多组存储文件，==保证其单个文件的执行效率==。</p>
<p>最常见的分区方案是按<code>id</code>分区，如下将<code>id</code>的哈希值对10取模将数据均匀分散到10个<code>.ibd</code>存储文件中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table article(</span><br><span class="line">	id int auto_increment PRIMARY KEY,</span><br><span class="line">	title varchar(64),</span><br><span class="line">	content text</span><br><span class="line">)PARTITION by HASH(id) PARTITIONS 10</span><br></pre></td></tr></table></figure></div><a class="more" href="/2017/11/23/Blog/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql-%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87-%E5%88%86%E5%8C%BA/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2017/11/18/Blog/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql-%E7%B4%A2%E5%BC%95/">mysql-索引</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-11-18</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/">mysql</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/mysql/">mysql</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E7%B4%A2%E5%BC%95/">索引</a></span><div class="content"><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><blockquote>
<p>关键字与数据的映射关系称为索引（==包含关键字和对应的记录在磁盘中的地址==）。关键字是从数据当中提取的用于标识、检索数据的特定内容。</p>
</blockquote>
<h2 id="索引检索为什么快？"><a href="#索引检索为什么快？" class="headerlink" title="索引检索为什么快？"></a>索引检索为什么快？</h2><ul>
<li>关键字相对于数据本身，==数据量小==</li>
<li>关键字是==有序==的，二分查找可快速确定位置</li>
</ul>
<p>图书馆为每本书都加了索引号（类别-楼层-书架）、字典为词语解释按字母顺序编写目录等都用到了索引。</p>
<h2 id="MySQL中索引类型"><a href="#MySQL中索引类型" class="headerlink" title="MySQL中索引类型"></a>MySQL中索引类型</h2><blockquote>
<p><strong>普通索引</strong>（<code>key</code>），<strong>唯一索引</strong>（<code>unique key</code>），<strong>主键索引</strong>（<code>primary key</code>），<strong>全文索引</strong>（<code>fulltext key</code>）</p>
</blockquote>
<p>三种索引的索引方式是一样的，只不过对索引的关键字有不同的限制：</p>
<ul>
<li>普通索引：对关键字没有限制</li>
<li>唯一索引：要求记录提供的关键字不能重复</li>
<li>主键索引：要求关键字唯一且不为null</li>
</ul></div><a class="more" href="/2017/11/18/Blog/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql-%E7%B4%A2%E5%BC%95/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2017/11/17/Blog/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql-MyISAM%E5%92%8CInnodb%E7%9A%84%E5%8C%BA%E5%88%AB/">mysql-MyISAM和Innodb的区别</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-11-17</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/">mysql</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/mysql/">mysql</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/MyISAM/">MyISAM</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Innodb/">Innodb</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E8%A1%8C%E9%94%81/">行锁</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E8%A1%A8%E9%94%81/">表锁</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E6%AD%BB%E9%94%81/">死锁</a></span><div class="content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>早期问题：如何选择MyISAM和Innodb？</p>
<p>现在不存在这个问题了，Innodb不断完善，从各个方面赶超MyISAM，也是MySQL默认使用的。</p>
</blockquote>
<p>存储引擎Storage engine：MySQL中的数据、索引以及其他对象是如何存储的，是一套文件系统的实现。</p>
<h2 id="功能差异"><a href="#功能差异" class="headerlink" title="功能差异"></a>功能差异</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show engines</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>Engine</th>
<th>Support</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>InnoDB</td>
<td>DEFAULT</td>
<td><strong>Supports transactions, row-level locking, and foreign keys</strong></td>
</tr>
<tr>
<td>MyISAM</td>
<td>YES</td>
<td><strong>MyISAM storage engine</strong></td>
</tr>
</tbody></table></div><a class="more" href="/2017/11/17/Blog/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql-MyISAM%E5%92%8CInnodb%E7%9A%84%E5%8C%BA%E5%88%AB/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2017/11/10/Blog/java/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8B+%E6%A0%91/">数据库索引为什么使用B+树</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-11-10</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/">mysql</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/">二叉树</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/mysql/">mysql</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E7%B4%A2%E5%BC%95/">索引</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/B-Tree/">B-Tree</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/B-Tree/">B+Tree</a></span><div class="content"><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>B-tree：</strong>B树，又名B tree（B-Tree，并不是B“减”树，横杠为连接符，容易被误导）<br>B树属于多叉树又名平衡多路查找树。每个节点可以多个数（由磁盘大小决定）。<br><strong>B+tree</strong> 和 <strong>B*tree</strong> 都是 B-tree的变种</p>
<h2 id="索引为什么是用B树呢？"><a href="#索引为什么是用B树呢？" class="headerlink" title="索引为什么是用B树呢？"></a>索引为什么是用B树呢？</h2><p>一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。而B-/+/*Tree，经过改进可以有效的利用系统对磁盘的块读取特性，在读取相同磁盘块的同时，尽可能多的加载索引数据，来提高索引命中效率，从而达到减少磁盘IO的读取次数。</p></div><a class="more" href="/2017/11/10/Blog/java/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8B+%E6%A0%91/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2017/11/07/Blog/java/%E5%85%B3%E4%BA%8ERESTfulAPI/">关于RESTfulAPI</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-11-07</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/java/">java</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/java/RESTful/">RESTful</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/RESTful/">RESTful</a></span><div class="content"><p><img src="http://image.icool8.cn/blog/20201206/IcoDnqenEioN.png?imageslim" alt="mark"></p>
<p>RESTful API 是每个程序员都应该了解并掌握的基本知识，我们在开发过程中设计 API 的时候也应该至少要满足 RESTful API 的最基本的要求（比如接口中尽量使用名词，使用 POST 请求创建资源，DELETE 请求删除资源等等，示例：<code>GET /notes/id</code>：获取某个指定 id 的笔记的信息）。</p>
<p><strong>RESTful API 可以你看到 url + http method 就知道这个 url 是干什么的，让你看到了 http 状态码（status code）就知道请求结果如何。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET    &#x2F;classes：列出所有班级</span><br><span class="line">POST   &#x2F;classes：新建一个班级</span><br></pre></td></tr></table></figure>
<p>下面的内容只是介绍了我觉得关于 RESTful API 比较重要的一些东西，欢迎补充。</p>
<h3 id="一、重要概念"><a href="#一、重要概念" class="headerlink" title="一、重要概念"></a>一、重要概念</h3><p>REST,即 <strong>REpresentational State Transfer</strong> 的缩写。这个词组的翻译过来就是”表现层状态转化”。这样理解起来甚是晦涩，实际上 REST 的全称是 <strong>Resource Representational State Transfer</strong> ，直白地翻译过来就是 <strong>“资源”在网络传输中以某种“表现形式”进行“状态转移”</strong> 。如果还是不能继续理解，请继续往下看，相信下面的讲解一定能让你理解到底啥是 REST 。</p>
<p>我们分别对上面涉及到的概念进行解读，以便加深理解，不过实际上你不需要搞懂下面这些概念，也能看懂我下一部分要介绍到的内容。不过，为了更好地能跟别人扯扯 “RESTful API”我建议你还是要好好理解一下！</p>
<ul>
<li><strong>资源（Resource）</strong> ：我们可以把真实的对象数据称为资源。一个资源既可以是一个集合，也可以是单个个体。比如我们的班级 classes 是代表一个集合形式的资源，而特定的 class 代表单个个体资源。每一种资源都有特定的 URI（统一资源定位符）与之对应，如果我们需要获取这个资源，访问这个 URI 就可以了，比如获取特定的班级：<code>/class/12</code>。另外，资源也可以包含子资源，比如 <code>/classes/classId/teachers</code>：列出某个指定班级的所有老师的信息</li>
<li><strong>表现形式（Representational）</strong>：”资源”是一种信息实体，它可以有多种外在表现形式。我们把”资源”具体呈现出来的形式比如 json，xml，image,txt 等等叫做它的”表现层/表现形式”。</li>
<li><strong>状态转移（State Transfer）</strong> ：大家第一眼看到这个词语一定会很懵逼？内心 BB：这尼玛是啥啊？ 大白话来说 REST 中的状态转移更多地描述的服务器端资源的状态，比如你通过增删改查（通过 HTTP 动词实现）引起资源状态的改变。ps:互联网通信协议 HTTP 协议，是一个无状态协议，所有的资源状态都保存在服务器端。</li>
</ul>
<p>综合上面的解释，我们总结一下什么是 RESTful 架构：</p>
<ol>
<li>每一个 URI 代表一种资源；</li>
<li>客户端和服务器之间，传递这种资源的某种表现形式比如 json，xml，image,txt 等等；</li>
<li>客户端通过特定的 HTTP 动词，对服务器端资源进行操作，实现”表现层状态转化”。</li>
</ol>
<h3 id="二、REST-接口规范"><a href="#二、REST-接口规范" class="headerlink" title="二、REST 接口规范"></a>二、REST 接口规范</h3><h4 id="1、动作"><a href="#1、动作" class="headerlink" title="1、动作"></a>1、动作</h4><ul>
<li>GET ：请求从服务器获取特定资源。举个例子：<code>GET /classes</code>（获取所有班级）</li>
<li>POST ：在服务器上创建一个新的资源。举个例子：<code>POST /classes</code>（创建班级）</li>
<li>PUT ：更新服务器上的资源（客户端提供更新后的整个资源）。举个例子：<code>PUT /classes/12</code>（更新编号为 12 的班级）</li>
<li>DELETE ：从服务器删除特定的资源。举个例子：<code>DELETE /classes/12</code>（删除编号为 12 的班级）</li>
<li>PATCH ：更新服务器上的资源（客户端提供更改的属性，可以看做作是部分更新），使用的比较少，这里就不举例子了。</li>
</ul>
<h4 id="2、路径（接口命名）"><a href="#2、路径（接口命名）" class="headerlink" title="2、路径（接口命名）"></a>2、路径（接口命名）</h4><p>路径又称”终点”（endpoint），表示 API 的具体网址。实际开发中常见的规范如下：</p>
<ol>
<li><strong>网址中不能有动词，只能有名词，API 中的名词也应该使用复数。</strong> 因为 REST 中的资源往往和数据库中的表对应，而数据库中的表都是同种记录的”集合”（collection）。<strong>如果 API 调用并不涉及资源（如计算，翻译等操作）的话，可以用动词。</strong> 比如：<code>GET /calculate?param1=11&amp;param2=33</code></li>
<li>不用大写字母，建议用中杠 - 不用下杠 _ 比如邀请码写成 <code>invitation-code</code>而不是 <del>invitation_code</del></li>
</ol>
<p>Talk is cheap！来举个实际的例子来说明一下吧！现在有这样一个 API 提供班级（class）的信息，还包括班级中的学生和教师的信息，则它的路径应该设计成下面这样。</p>
<p><strong>接口尽量使用名词，禁止使用动词。</strong> 下面是一些例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET    &#x2F;classes：列出所有班级</span><br><span class="line">POST   &#x2F;classes：新建一个班级</span><br><span class="line">GET    &#x2F;classes&#x2F;classId：获取某个指定班级的信息</span><br><span class="line">PUT    &#x2F;classes&#x2F;classId：更新某个指定班级的信息（一般倾向整体更新）</span><br><span class="line">PATCH  &#x2F;classes&#x2F;classId：更新某个指定班级的信息（一般倾向部分更新）</span><br><span class="line">DELETE &#x2F;classes&#x2F;classId：删除某个班级</span><br><span class="line">GET    &#x2F;classes&#x2F;classId&#x2F;teachers：列出某个指定班级的所有老师的信息</span><br><span class="line">GET    &#x2F;classes&#x2F;classId&#x2F;students：列出某个指定班级的所有学生的信息</span><br><span class="line">DELETE classes&#x2F;classId&#x2F;teachers&#x2F;ID：删除某个指定班级下的指定的老师的信息</span><br></pre></td></tr></table></figure>
<p>反例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;getAllclasses</span><br><span class="line">&#x2F;createNewclass</span><br><span class="line">&#x2F;deleteAllActiveclasses</span><br></pre></td></tr></table></figure>
<p>理清资源的层次结构，比如业务针对的范围是学校，那么学校会是一级资源:<code>/schools</code>，老师: <code>/schools/teachers</code>，学生: <code>/schools/students</code> 就是二级资源。</p>
<h4 id="3、过滤信息（Filtering）"><a href="#3、过滤信息（Filtering）" class="headerlink" title="3、过滤信息（Filtering）"></a>3、过滤信息（Filtering）</h4><p>如果我们在查询的时候需要添加特定条件的话，建议使用 url 参数的形式。比如我们要查询 state 状态为 active 并且 name 为 guidegege 的班级：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET    &#x2F;classes?state&#x3D;active&amp;name&#x3D;guidegege</span><br></pre></td></tr></table></figure>
<p>比如我们要实现分页查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET    &#x2F;classes?page&#x3D;1&amp;size&#x3D;10 &#x2F;&#x2F;指定第1页，每页10个数据</span><br></pre></td></tr></table></figure>
<h4 id="4、状态码（Status-Codes）"><a href="#4、状态码（Status-Codes）" class="headerlink" title="4、状态码（Status Codes）"></a>4、状态码（Status Codes）</h4><p><strong>状态码范围：</strong></p>
<table>
<thead>
<tr>
<th>2xx：成功</th>
<th>3xx：重定向</th>
<th>4xx：客户端错误</th>
<th>5xx：服务器错误</th>
</tr>
</thead>
<tbody><tr>
<td>200 成功</td>
<td>301 永久重定向</td>
<td>400 错误请求</td>
<td>500 服务器错误</td>
</tr>
<tr>
<td>201 创建</td>
<td>304 资源未修改</td>
<td>401 未授权</td>
<td>502 网关错误</td>
</tr>
<tr>
<td></td>
<td></td>
<td>403 禁止访问</td>
<td>504 网关超时</td>
</tr>
<tr>
<td></td>
<td></td>
<td>404 未找到</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>405 请求方法不对</td>
<td></td>
</tr>
</tbody></table>
<h3 id="三-HATEOAS"><a href="#三-HATEOAS" class="headerlink" title="三 HATEOAS"></a>三 HATEOAS</h3><blockquote>
<p><strong>RESTful 的极致是 hateoas ，但是这个基本不会在实际项目中用到。</strong></p>
</blockquote>
<p>上面是 RESTful API 最基本的东西，也是我们平时开发过程中最容易实践到的。实际上，RESTful API 最好做到 Hypermedia，即返回结果中提供链接，连向其他 API 方法，使得用户不查文档，也知道下一步应该做什么。</p>
<p>比如，当用户向 api.example.com 的根目录发出请求，会得到这样一个文档。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;link&quot;: &#123;</span><br><span class="line">  &quot;rel&quot;:   &quot;collection https:&#x2F;&#x2F;www.example.com&#x2F;classes&quot;,</span><br><span class="line">  &quot;href&quot;:  &quot;https:&#x2F;&#x2F;api.example.com&#x2F;classes&quot;,</span><br><span class="line">  &quot;title&quot;: &quot;List of classes&quot;,</span><br><span class="line">  &quot;type&quot;:  &quot;application&#x2F;vnd.yourformat+json&quot;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码表示，文档中有一个 link 属性，用户读取这个属性就知道下一步该调用什么 API 了。rel 表示这个 API 与当前网址的关系（collection 关系，并给出该 collection 的网址），href 表示 API 的路径，title 表示 API 的标题，type 表示返回类型 Hypermedia API 的设计被称为<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/HATEOAS">HATEOAS</a>。</p>
<p>在 Spring 中有一个叫做 HATEOAS 的 API 库，通过它我们可以更轻松的创建除符合 HATEOAS 设计的 API。</p>
<h3 id="文章推荐"><a href="#文章推荐" class="headerlink" title="文章推荐"></a>文章推荐</h3><p><strong>RESTful API 介绍：</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://restfulapi.net/">RESTful API Tutorial</a></li>
<li><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2014/05/RESTful_api.html">RESTful API 最佳指南</a>（阮一峰，这篇文章大部分内容来源）</li>
<li>[<a target="_blank" rel="noopener" href="https://juejin.im/entry/59e460c951882542f578f2f0">译] RESTful API 设计最佳实践</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000016313947">那些年，我们一起误解过的 REST</a></li>
<li><a target="_blank" rel="noopener" href="https://phauer.com/2016/testing-RESTful-services-java-best-practices/">Testing RESTful Services in Java: Best Practices</a></li>
</ul>
<p><strong>Spring 中使用 HATEOAS：</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/system-design/coding-way/a">在 Spring Boot 中使用 HATEOAS</a></li>
<li><a target="_blank" rel="noopener" href="https://spring.io/guides/tutorials/classmarks/">Building REST services with Spring</a> (Spring 官网 )</li>
<li><a target="_blank" rel="noopener" href="https://www.baeldung.com/spring-hateoas-tutorial">An Intro to Spring HATEOAS</a> （by <a target="_blank" rel="noopener" href="https://www.baeldung.com/author/baeldung/">baeldung</a>）</li>
<li><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-hateoas-examples/tree/master/hypermedia">spring-hateoas-examples</a></li>
<li><a target="_blank" rel="noopener" href="https://spring.io/projects/spring-hateoas#learn">Spring HATEOAS</a> (Spring 官网 )</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2017/10/30/Blog/java/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/%EF%BC%88%E5%85%AB%EF%BC%89JVM%E8%B0%83%E4%BC%98-jstat%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/">（八）JVM调优-jstat工具的使用.</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-10-30</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/java/">java</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/">java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/jvm/">jvm</a></span><div class="content"><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>jstat命令可以查看堆内存各部分的使用量，以及加载类的数量。命令的格式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat [-命令选项] [vmid] [间隔时间/毫秒] [查询次数]</span><br></pre></td></tr></table></figure>
<h3 id="二、用法"><a href="#二、用法" class="headerlink" title="二、用法"></a>二、用法</h3><h4 id="1、印类加载统计-class"><a href="#1、印类加载统计-class" class="headerlink" title="1、印类加载统计-class"></a>1、印类加载统计-class</h4><ul>
<li>-class打印类加载的情况.</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">^C[root@crmadapter logs]<span class="comment"># jstat -class 5274 1000 5</span></span><br><span class="line">Loaded  Bytes  Unloaded  Bytes     Time   </span><br><span class="line"> 12936 25356.0     1517  1776.0      45.12</span><br><span class="line"> 12936 25356.0     1517  1776.0      45.12</span><br><span class="line"> 12936 25356.0     1517  1776.0      45.12</span><br><span class="line"> 12936 25356.0     1517  1776.0      45.12</span><br><span class="line"> 12936 25356.0     1517  1776.0      45.12</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li>**Loaded:**加载class的数量</li>
<li><strong>Bytes：</strong>所占用空间大小</li>
<li><strong>Unloaded：</strong>未加载数量</li>
<li>**Bytes:**未加载占用空间</li>
<li><strong>Time：</strong>时间</li>
</ul></div><a class="more" href="/2017/10/30/Blog/java/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/%EF%BC%88%E5%85%AB%EF%BC%89JVM%E8%B0%83%E4%BC%98-jstat%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2017/10/19/Blog/java/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/%EF%BC%88%E4%B8%83%EF%BC%89JVM%E8%B0%83%E4%BC%98-jmap%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/">（七）JVM调优-jmap工具的使用.</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-10-19</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/java/">java</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/">java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/jvm/">jvm</a></span><div class="content"><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>jmap命令是一个可以输出所有内存中对象的工具，甚至可以将VM 中的heap，以二进制输出成文本。打印出某个java进程（使用pid）内存内的，所有‘对象’的情况（如：产生那些对象，及其数量）。</p>
<h3 id="二、命令格式"><a href="#二、命令格式" class="headerlink" title="二、命令格式"></a>二、命令格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">jmap [option] &lt;pid&gt;</span><br><span class="line">  (to connect to running process) 连接到正在运行的进程</span><br><span class="line">jmap [option] &lt;executable &lt;core&gt;</span><br><span class="line">  (to connect to a core file)     连接到核心文件</span><br><span class="line">jmap [option] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class="line">  (to connect to remote debug server) 连接到远程调试服务</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">## 参数说明</span></span><br><span class="line">&gt;    pid:    目标进程的PID，进程编号，可以采用ps -ef | grep java 查看java进程的PID;</span><br><span class="line">&gt;    executable:     产生core dump的java可执行程序;</span><br><span class="line">&gt;    core:     将被打印信息的core dump文件;</span><br><span class="line">&gt;    remote-hostname-or-IP:     远程debug服务的主机名或ip;</span><br><span class="line">&gt;    server-id:     唯一id,假如一台主机上多个远程debug服务;</span><br></pre></td></tr></table></figure></div><a class="more" href="/2017/10/19/Blog/java/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/%EF%BC%88%E4%B8%83%EF%BC%89JVM%E8%B0%83%E4%BC%98-jmap%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2017/10/19/Blog/java/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/%EF%BC%88%E5%85%AD%EF%BC%89JVM%E8%B0%83%E4%BC%98-jstack%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/">（六）JVM调优-jstack工具的使用.</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-10-19</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/java/">java</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/">java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/jvm/">jvm</a></span><div class="content"><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>JDK本身提供了很多方便的JVM性能调优监控工具，除了集成式的VisualVM和jConsole外， 还有jps、jstack、jmap、jhat、jstat、hprof等小巧的工具，每一种工具都有其自身的特点， 用户可以根据你需要检测的应用或者程序片段的状况，适当的选择相应的工具进行检测， 先通过一个表格形式简要介绍下这几个命令的作用和使用方法。本文重点介绍jstack的使用方法。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>jps</td>
<td>基础工具</td>
</tr>
<tr>
<td>jstack</td>
<td>查看某个Java进程内的线程堆栈信息</td>
</tr>
<tr>
<td>jmap</td>
<td>jmap导出堆内存，然后使用jhat来进行分析</td>
</tr>
<tr>
<td>jhat</td>
<td>jmap导出堆内存，然后使用jhat来进行分析</td>
</tr>
<tr>
<td>jstat</td>
<td>JVM统计监测工具</td>
</tr>
<tr>
<td>hprof</td>
<td>hprof能够展现CPU使用率，统计堆内存使用情况</td>
</tr>
</tbody></table></div><a class="more" href="/2017/10/19/Blog/java/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/%EF%BC%88%E5%85%AD%EF%BC%89JVM%E8%B0%83%E4%BC%98-jstack%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/#more">Read more</a><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By Jia Xufeng</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>