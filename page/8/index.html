<!DOCTYPE html><html lang="zh-tw"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Jia Xufeng"><meta name="copyright" content="Jia Xufeng"><title>向暗夜致敬 | 暗夜精灵のBlog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 5.3.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="http://image.icool8.cn/bolg/20210107112538.png"></div><div class="author-info__name text-center">Jia Xufeng</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">89</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">85</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">31</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友情链接</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://wiliam.me/">wiliam</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://molunerfinn.com/hexo-theme-melody-doc/zh-Hans/">melody</a></div></div></div><nav id="nav" style="background-image: url(http://image.icool8.cn/bolg/20210107113114.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">暗夜精灵のBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">暗夜精灵のBlog</div><div id="site-sub-title">向暗夜致敬</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2017/10/19/Blog/java/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/%EF%BC%88%E4%B8%83%EF%BC%89JVM%E8%B0%83%E4%BC%98-jmap%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/">（七）JVM调优-jmap工具的使用.</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-10-19</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/java/">java</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/">java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/jvm/">jvm</a></span><div class="content"><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>jmap命令是一个可以输出所有内存中对象的工具，甚至可以将VM 中的heap，以二进制输出成文本。打印出某个java进程（使用pid）内存内的，所有‘对象’的情况（如：产生那些对象，及其数量）。</p>
<h3 id="二、命令格式"><a href="#二、命令格式" class="headerlink" title="二、命令格式"></a>二、命令格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">jmap [option] &lt;pid&gt;</span><br><span class="line">  (to connect to running process) 连接到正在运行的进程</span><br><span class="line">jmap [option] &lt;executable &lt;core&gt;</span><br><span class="line">  (to connect to a core file)     连接到核心文件</span><br><span class="line">jmap [option] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class="line">  (to connect to remote debug server) 连接到远程调试服务</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">## 参数说明</span></span><br><span class="line">&gt;    pid:    目标进程的PID，进程编号，可以采用ps -ef | grep java 查看java进程的PID;</span><br><span class="line">&gt;    executable:     产生core dump的java可执行程序;</span><br><span class="line">&gt;    core:     将被打印信息的core dump文件;</span><br><span class="line">&gt;    remote-hostname-or-IP:     远程debug服务的主机名或ip;</span><br><span class="line">&gt;    server-id:     唯一id,假如一台主机上多个远程debug服务;</span><br></pre></td></tr></table></figure></div><a class="more" href="/2017/10/19/Blog/java/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/%EF%BC%88%E4%B8%83%EF%BC%89JVM%E8%B0%83%E4%BC%98-jmap%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2017/10/19/Blog/java/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/%EF%BC%88%E5%85%AD%EF%BC%89JVM%E8%B0%83%E4%BC%98-jstack%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/">（六）JVM调优-jstack工具的使用.</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-10-19</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/java/">java</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/">java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/jvm/">jvm</a></span><div class="content"><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>JDK本身提供了很多方便的JVM性能调优监控工具，除了集成式的VisualVM和jConsole外， 还有jps、jstack、jmap、jhat、jstat、hprof等小巧的工具，每一种工具都有其自身的特点， 用户可以根据你需要检测的应用或者程序片段的状况，适当的选择相应的工具进行检测， 先通过一个表格形式简要介绍下这几个命令的作用和使用方法。本文重点介绍jstack的使用方法。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>jps</td>
<td>基础工具</td>
</tr>
<tr>
<td>jstack</td>
<td>查看某个Java进程内的线程堆栈信息</td>
</tr>
<tr>
<td>jmap</td>
<td>jmap导出堆内存，然后使用jhat来进行分析</td>
</tr>
<tr>
<td>jhat</td>
<td>jmap导出堆内存，然后使用jhat来进行分析</td>
</tr>
<tr>
<td>jstat</td>
<td>JVM统计监测工具</td>
</tr>
<tr>
<td>hprof</td>
<td>hprof能够展现CPU使用率，统计堆内存使用情况</td>
</tr>
</tbody></table></div><a class="more" href="/2017/10/19/Blog/java/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/%EF%BC%88%E5%85%AD%EF%BC%89JVM%E8%B0%83%E4%BC%98-jstack%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2017/10/07/Blog/java/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/%EF%BC%88%E4%BA%94%EF%BC%89jvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%B0%83%E4%BC%98/">（五）jvm虚拟机调优.</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-10-07</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/java/">java</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/">java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/jvm/">jvm</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/gc/">gc</a></span><div class="content"><h2 id="常见配置汇总"><a href="#常见配置汇总" class="headerlink" title="常见配置汇总"></a>常见配置汇总</h2><h3 id="堆设置"><a href="#堆设置" class="headerlink" title="堆设置"></a>堆设置</h3><ul>
<li><strong>-Xms</strong> :初始堆大小</li>
<li><strong>-Xmx</strong> :最大堆大小</li>
<li><strong>-XX:NewSize=n</strong> :设置年轻代大小</li>
<li><strong>-XX:NewRatio=n:</strong> 设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4</li>
<li><strong>-XX:SurvivorRatio=n</strong> :年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5</li>
<li><strong>-XX:MaxPermSize=n</strong> :设置持久代大小</li>
</ul>
<h3 id="收集器设置"><a href="#收集器设置" class="headerlink" title="收集器设置"></a>收集器设置</h3><ul>
<li><strong>-XX:+UseSerialGC</strong> :设置串行收集器</li>
<li><strong>-XX:+UseParallelGC</strong> :设置并行收集器</li>
<li><strong>-XX:+UseParalledlOldGC</strong> :设置并行年老代收集器</li>
<li><strong>-XX:+UseConcMarkSweepGC</strong> :设置并发收集器</li>
</ul></div><a class="more" href="/2017/10/07/Blog/java/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/%EF%BC%88%E4%BA%94%EF%BC%89jvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%B0%83%E4%BC%98/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2017/10/01/Blog/java/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/%EF%BC%88%E5%9B%9B%EF%BC%89%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6GC/">（四）垃圾回收GC</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-10-01</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/java/">java</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/">java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/jvm/">jvm</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/gc/">gc</a></span><div class="content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在学习Java GC 之前，我们需要记住一个单词：stop-the-world 。它会在任何一种GC算法中发生。stop-the-world 意味着JVM因为需要执行GC而停止了应用程序的执行。当stop-the-world 发生时，除GC所需的线程外，所有的线程都进入等待状态，直到GC任务完成。GC优化很多时候就是减少stop-the-world 的发生。</p>
<p>JVM GC只回收堆区和方法区内的对象。而栈区的数据，在超出作用域后会被JVM自动释放掉，所以其不在JVM GC的管理范围内。</p>
<h2 id="GC如何判断对象已“死”"><a href="#GC如何判断对象已“死”" class="headerlink" title="GC如何判断对象已“死”"></a>GC如何判断对象已“死”</h2><p>Java堆中存放着几乎所有的对象实例，垃圾回收器在堆进行垃圾回收前，首先要判断这些对象那些还存活，那些已经“死去”。判断对象是否已“死”有如下几种算法：</p>
<h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>引用计数法描述的算法为：给对象增加一个引用计数器，每当有一个地方引用它时，计数器就+1；当引用失效时，计数器就-1；任何时刻计数器为0的对象就是不能再被使用的，即对象已“死”。引用计数法实现简单，判定效率也比较高，在大部分情况下都是一个比较好的算法。比如Python语言就是采用的引用计数法来进行内存管的。<br><strong>但是，在主流的JVM中没有选用引用计数法来管理内存，最主要的原因是引用计数法无法解决对象的循环引用问题。</strong></p></div><a class="more" href="/2017/10/01/Blog/java/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/%EF%BC%88%E5%9B%9B%EF%BC%89%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6GC/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2017/10/01/Blog/java/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/%EF%BC%88%E4%B8%89%EF%BC%89java%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/">（三）java对象模型</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-10-01</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/java/">java</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/">java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/jvm/">jvm</a></span><div class="content"><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>了解了java内存模型后，有必要对java的对象模型也做个简单的了解，这里非常浅显的总结介绍java对象模型。</p>
<p>关于一个Java对象，他的存储是怎样的，一般很多人会回答：对象存储在堆上。稍微好一点的人会回答：对象存储在堆上，对象的引用存储在栈上。今天，再给你一个更加显得牛逼的回答：</p>
<p><strong>对象的实例（instantOopDesc)保存在堆上，对象的元数据（instantKlass）保存在方法区，对象的引用保存在栈上</strong></p>
<h3 id="java对象模型"><a href="#java对象模型" class="headerlink" title="java对象模型"></a>java对象模型</h3><p>Java是一种面向对象的语言，而Java对象在JVM中的存储也是有一定的结构的。而这个关于Java对象自身的存储模型称之为Java对象模型。<br>HotSpot虚拟机中，设计了一个OOP-Klass Model。OOP（Ordinary Object Pointer）指的是普通对象指针，而Klass用来描述对象实例的具体类型。</p></div><a class="more" href="/2017/10/01/Blog/java/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/%EF%BC%88%E4%B8%89%EF%BC%89java%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2017/10/01/Blog/java/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/%EF%BC%88%E4%BA%8C%EF%BC%89jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/">（二）java内存结构</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-10-01</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/java/">java</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/">java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/jvm/">jvm</a></span><div class="content"><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>jvm内存结构（java内存结构）是java运行的基础，在此基础上才有的java内存模型和java对象模型等基本模型理论。</p>
<h2 id="java内存模型"><a href="#java内存模型" class="headerlink" title="java内存模型"></a>java内存模型</h2><p>根据java虚拟机规范，java虚拟机管理的内存将分为下面五大区域。</p>
<p><img src="http://image.icool8.cn/blog/20200110/NIEs32HhwxrL.jpg?imageslim" alt="mark"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">从上面这张图可以看出来，Java数据区域分为五大数据区域。其中方法区和堆是所有线程共享的，栈，本地方法栈和程序虚拟机则为线程私有的。</span><br></pre></td></tr></table></figure></div><a class="more" href="/2017/10/01/Blog/java/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/%EF%BC%88%E4%BA%8C%EF%BC%89jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2017/10/01/Blog/java/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/%EF%BC%88%E4%B8%80%EF%BC%89java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">（一）java内存模型</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-10-01</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/java/">java</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/">java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/jvm/">jvm</a></span><div class="content"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近发现好多人分不清楚到底什么是java内存模型、什么是jvm内存结构，甚至是工作五六年的高T也分不大清，所以想写下我的理解，如有不对的地方，请多多指教。</p>
<p>java内存模型（又称jvm内存模型）与jvm内存结构（又称java内存结构）两者概念不同，说的是两码事儿。Java内存模型是根据英文Java Memory Model（JMM）翻译过来的，JMM是抽象出来的一组概念、约束、或者说是一种规范，描述java是怎样在多线程环境下工作的。而JVM描述的是JVM如何将内存加以区分，以及各个分区的作用。</p>
<p><strong>java内存模型是jvm内存结构的基础上建立的一种规范，简要言之，jmm是jvm的一种规范</strong></p>
<h3 id="java内存模型"><a href="#java内存模型" class="headerlink" title="java内存模型"></a>java内存模型</h3><p>了解jvm内存模型前，了解下cpu和计算机内存的交互情况。【因为Java虚拟机内存模型定义的访问操作与计算机十分相似】</p>
<p>有篇很棒的文章，从cpu讲到内存模型:<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/bf158fbb2432">什么是java内存模型</a></p></div><a class="more" href="/2017/10/01/Blog/java/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/%EF%BC%88%E4%B8%80%EF%BC%89java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2017/10/01/Blog/java/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/VOLATILE%E5%8E%9F%E7%90%86%20+%20HAPPENS-BEFORE%E5%8E%9F%E5%88%99/">VOLATILE原理 + HAPPENS-BEFORE原则</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-10-01</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/java/">java</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/">java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/jvm/">jvm</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/volatile/">volatile</a></span><div class="content"><h2 id="HAPPENS-BEFORE原则"><a href="#HAPPENS-BEFORE原则" class="headerlink" title="HAPPENS-BEFORE原则"></a>HAPPENS-BEFORE原则</h2><p>同一个线程中的，前面的操作 happens-before 后续的操作。（即单线程内按代码顺序执行。但是，在不影响在单线程环境执行结果的前提下，编译器和处理器可以进行重排序，这是合法的。换句话说，这一规则是无法保证编译重排和指令重排）。</p>
<ul>
<li>监视器上的解锁操作 happens-before 其后续的加锁操作。（Synchronized 规则）</li>
<li>对volatile变量的写操作 happens-before 后续的读操作。（volatile 规则）</li>
<li>线程的start() 方法 happens-before 该线程所有的后续操作。（线程启动规则）</li>
<li>线程所有的操作 happens-before 其他线程在该线程上调用 join 返回成功后的操作。</li>
<li>如果 a happens-before b，b happens-before c，则a happens-before c（传递性）</li>
</ul>
<p>以下描述是<strong>不准确</strong>的：“volatile变量对所有线程是立即可见的，对volatile变量所有的写操作都能立即反馈到其他线程中，volatile变量在各个线程中都是一致的，所以基于volatile变量的运算在并发下安全的”.</p>
<p><strong>Volatile无法保证原子性</strong></p>
<p>使用volatile关键字虽然能够使线程共享的变量在并发情况下完全可见，起到线程信息交互和通信的作用，但对于非原子操作，volatile并不能保证该操作的原子性（即操作过程被其他线程干扰导致信息错误和信息丢失），最简单的例子就是i++这样的自增操作</p>
<h2 id="VOLATILE关键字的作用"><a href="#VOLATILE关键字的作用" class="headerlink" title="VOLATILE关键字的作用"></a>VOLATILE关键字的作用</h2><p>volatile关键字主要用于保证内存可见性和顺序性，以及操作的原子性：</p>
<ul>
<li><p>volatile修饰的变量可以保证一个线程对该变量的<strong>写</strong>happens-before 一个线程对该变量的**读</p>
</li>
<li><p>volatile在双重检查加锁的单例模式中的应用，可以<strong>防止重排序</strong></p>
</li>
</ul>
<p><img src="http://image.icool8.cn/blog/20201202/hOEFjHc8eSiW.png?imageslim" alt="mark"></p>
<h2 id="VOLATILE关键字的实现原理"><a href="#VOLATILE关键字的实现原理" class="headerlink" title="VOLATILE关键字的实现原理"></a>VOLATILE关键字的实现原理</h2><p>在java代码编译成字节码时会在volatile修饰的共享变量进行写操作的时候会多出Lock前缀的指令。</p>
<p>我们知道为了提高处理速度，CPU不直接和内存进行通信，而是先将系统内存的数据读到内部缓存（L1，L2或其他）后再进行操作，但操作完不知道何时会写回内存。如果对声明了volatile的变量进行写操作，JVM就会向CPU发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是，就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。所以，在多处理器下，为了保证各个CPU的缓存是一致的，就会实现缓存一致性协议，每个CPU通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前CPU的缓存行设置成无效状态，当CPU对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里</p>
<ol>
<li>Lock前缀的指令会引起CPU缓存写回内存；</li>
<li>一个CPU的缓存回写到内存会导致其他处理器的缓存失效；</li>
<li>当CPU发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值。</li>
</ol>
<p>这样针对volatile变量通过这样的机制就使得每个线程都能获得该变量的最新值</p>
<p>volatile相关的理解就写到这里，如果大家还想详细的了解volatile可以查阅相关资料或者私信我进行交流。</p>
<p>并发是java中无法避免的问题，基本上java面试都会涉及一些并发相关的问题，尤其是互联网公司一定会问到，今天就先写到了这里，下次准备把并发中相关的锁和并发集合的知识整理一下分享给大家，如果喜欢记得关注我【不爱八阿哥】，有什么问题也可以私信交流，让我们共同进步。</p>
<h2 id="Volatile结合CAS实现原子性"><a href="#Volatile结合CAS实现原子性" class="headerlink" title="Volatile结合CAS实现原子性"></a>Volatile结合CAS实现原子性</h2><p>CAS（CompareAndSwap）比较交换原则结合volatile，就能够实现基本的线程安全，典型的应用就是concurrent包下的Atomic类，上述例子如果用AtomicInteger代替int，就能够实现自增情况下的线程安全 。</p>
<p>但是依然会存在ABA的问题，为了杜绝ABA问题，可以借助版本号来实现，另外JDK1.5之后提供了AtomicStampedReference类也可以解决ABA问题，这里就不多做阐述了，有兴趣的同学可以去了解一下。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2017/09/19/Blog/%E7%94%9F%E6%B4%BB/%E8%8D%AF%E5%93%81%E6%B8%85%E5%8D%95/">药品清单</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-09-19</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E7%94%9F%E6%B4%BB/">生活</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E7%94%9F%E6%B4%BB/">生活</a></span><div class="content"><h3 id="高血压"><a href="#高血压" class="headerlink" title="高血压"></a>高血压</h3><ul>
<li><p><strong>阿托伐他汀钙片</strong> 【优力平】*<em>10mg</em>14片/盒** 活动：<strong>20/盒</strong>   【立普妥】 <strong>58=7片</strong></p>
</li>
<li><p><strong>益脑宁片</strong> 【华雨】 <strong>0.37g<em>48片/盒**(十盒=360) 活动：<strong>25.2/盒</strong>   【修正】**0.37g\</em>36片 52/每盒</strong></p>
<p>华雨的效果挺好，可是现在买不到了，不知道是换厂家了还是倒闭了。这种药不敢随便乱换，目前考虑换成修正的，虽然贵了点，但是是大牌子，质量和药效有保障。</p>
<p>或者将益脑宁换成步长脑心通胶囊。</p>
</li>
<li><p><strong>苯磺酸氨氯地平片</strong> 【护佑 兰迪】*<em>5mg</em>28片/盒** 活动：<strong>31.2/盒</strong></p>
</li>
<li><p><strong>富马酸比索洛尔片</strong>【康忻】 *<em>5mg</em>10片/盒**    活动：<strong>27.3/盒</strong></p>
</li>
<li><p><strong>脑心通胶囊</strong> 【步长】 <strong>0.4g*36粒（2板*18粒）</strong> <strong>23.80/盒</strong></p>
</li>
</ul>
<h3 id="糖尿病"><a href="#糖尿病" class="headerlink" title="糖尿病"></a>糖尿病</h3><ul>
<li><strong>盐酸二甲双胍缓释片</strong> 【格华止】 *<em>0.5g</em>30片/盒** 每天4片 <strong>43/盒</strong></li>
<li><strong>卡格列净片</strong> 【怡可安】 *<em>100mg</em>10片/盒** 每天1片 <strong>40/盒</strong></li>
<li><strong>阿卡波糖片</strong>【拜糖苹】 *<em>50mg</em>30片/盒** 每天6片 <strong>16/盒</strong></li>
</ul>
<h3 id="提高免疫力"><a href="#提高免疫力" class="headerlink" title="提高免疫力"></a>提高免疫力</h3><ul>
<li><strong>汤臣倍健蛋白粉</strong></li>
<li><strong>香菇菌多糖片</strong> 【天青】 *<em>10mg</em>24片/盒** <strong>13/盒</strong></li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2017/08/13/Blog/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/">二叉树的遍历</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-08-13</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/java/">java</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/java/%E7%AE%97%E6%B3%95/">算法</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/">二叉树</a></span><div class="content"><p>1、先序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 先序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preLoop</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(node.getName());</span><br><span class="line">        <span class="keyword">if</span> (node.getRight() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            preLoop(node.getRight());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.getLeft() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            preLoop(node.getLeft());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>2、中序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preLoop</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.getRight() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        preLoop(node.getRight());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(node.getName());</span><br><span class="line">    <span class="keyword">if</span> (node.getLeft() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        preLoop(node.getLeft());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、后序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preLoop</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.getRight() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        preLoop(node.getRight());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.getLeft() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        preLoop(node.getLeft());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(node.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(http://image.icool8.cn/bolg/20210107113114.png)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By Jia Xufeng</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>