<!DOCTYPE html><html lang="zh-tw"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Jia Xufeng"><meta name="copyright" content="Jia Xufeng"><title>向暗夜致敬 | 暗夜精灵のBlog</title><link rel="shortcut icon" href="http://image.icool8.cn/blog/20200618/tlIPrUJYHhnI.png?imageslim"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 5.3.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="http://image.icool8.cn/blog/20200618/tlIPrUJYHhnI.png?imageslim"></div><div class="author-info__name text-center">Jia Xufeng</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">85</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">83</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">29</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">暗夜精灵のBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">暗夜精灵のBlog</div><div id="site-sub-title">向暗夜致敬</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/12/Blog/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%8D%95%E4%BE%8B-%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81/">单例-双重检查锁</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-12</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/">java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">单例模式</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81/">双重检查锁</a></span><div class="content"><h2 id="首先我们回顾一下最简单的单例模式是怎样的？"><a href="#首先我们回顾一下最简单的单例模式是怎样的？" class="headerlink" title="首先我们回顾一下最简单的单例模式是怎样的？"></a>首先我们回顾一下最简单的单例模式是怎样的？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*单例模式一：懒汉式（线程安全）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton1 singleton1;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            singleton1 = <span class="keyword">new</span> Singleton1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个懒汉式的单例实现，众所周知，因为没有相应的锁机制，这个程序是线程不安全的，实现安全的最快捷的方式是添加 synchronized</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单例模式二：懒汉式（线程安全）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton2 singleton2;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            singleton2 = <span class="keyword">new</span> Singleton2();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用synchronized之后，可以保证线程安全，但是synchronized将全部代码块锁住，这样会导致较大的性能开销，因此，人们想出了一个“聪明”的技巧：双重检查锁DCL(double checked locking)的机制实现单例。</p>
<h2 id="双重坚持锁"><a href="#双重坚持锁" class="headerlink" title="双重坚持锁"></a>双重坚持锁</h2><p>一个双重检查锁实现的单例如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单例模式三：DCL(double checked locking)双重校验锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton3 singleton3;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton3 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton3.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton3 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleton3 = <span class="keyword">new</span> Singleton3();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上面代码所示，如果第一次检查instance不为null，那么就不需要执行下面的加锁和初始化操作。因此可以大幅降低synchronized带来的性能开销。上面代码表面上看起来，似乎两全其美：</p>
<ol>
<li>在多个线程试图在同一时间创建对象时，会通过加锁来保证只有一个线程能创建对象。</li>
<li>在对象创建好之后，执行getInstance()将不需要获取锁，直接返回已创建好的对象。</li>
</ol>
<p>程序看起来很完美，但是这是一个不完备的优化，在线程执行到第9行代码读取到instance不为null时（第一个if），instance引用的对象有可能还没有完成初始化。</p>
<h2 id="问题的根源"><a href="#问题的根源" class="headerlink" title="问题的根源"></a>问题的根源</h2><p>问题出现在创建对象的语句<code>singleton3 = new Singleton3();</code> 上，在java中创建一个对象并非是一个原子操作，可以被分解成三行伪代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1：分配对象的内存空间</span></span><br><span class="line">memory = allocate();</span><br><span class="line"><span class="comment">//2：初始化对象</span></span><br><span class="line">ctorInstance(memory);  </span><br><span class="line"><span class="comment">//3：设置instance指向刚分配的内存地址</span></span><br><span class="line">instance = memory;     </span><br></pre></td></tr></table></figure>
<p>上面三行伪代码中的2和3之间，可能会被重排序（在一些JIT编译器中）,即编译器或处理器为提高性能改变代码执行顺序，这一部分的内容稍后会详细解释，重排序之后的伪代码是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1：分配对象的内存空间</span></span><br><span class="line">memory = allocate(); </span><br><span class="line"><span class="comment">//3：设置instance指向刚分配的内存地址</span></span><br><span class="line">instance = memory;</span><br><span class="line"><span class="comment">//2：初始化对象</span></span><br><span class="line">ctorInstance(memory);</span><br></pre></td></tr></table></figure>
<p>在单线程程序下，重排序不会对最终结果产生影响，但是并发的情况下，可能会导致某些线程访问到未初始化的变量。</p>
<p>模拟一个2个线程创建单例的场景，如下表：</p>
<table>
<thead>
<tr>
<th align="left">时间</th>
<th align="left">线程A</th>
<th align="left">线程B</th>
</tr>
</thead>
<tbody><tr>
<td align="left">t1</td>
<td align="left">A1:分配对象内存空间</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">t2</td>
<td align="left">A3：设置instance指向内存空间</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">t3</td>
<td align="left"></td>
<td align="left">B1：判断instance是否为空</td>
</tr>
<tr>
<td align="left">t4</td>
<td align="left"></td>
<td align="left">B2：由于instance不为null，线程B将访问instance引用的对象</td>
</tr>
<tr>
<td align="left">t5</td>
<td align="left">A2：初始化对象</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">t6</td>
<td align="left">A4：访问instance引用的对象</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>按照这样的顺序执行，线程B将会获得一个未初始化的对象，并且自始至终，线程B无需获取锁！</p>
<h2 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h2><p>前面我们已经分析到，导致问题的原因在于“指令重排序”，那么什么是“指令重排序”，它为什么在并发时会影响到程序处理结果？ 首先我们看一下“顺序一致性内存模型”概念。</p>
<h2 id="顺序一致性理论内存模型"><a href="#顺序一致性理论内存模型" class="headerlink" title="顺序一致性理论内存模型"></a>顺序一致性理论内存模型</h2><p>顺序一致性内存模型是一个被计算机科学家理想化了的理论参考模型，它为程序员提供了极强的内存可见性保证。顺序一致性内存模型有两大特性：</p>
<ol>
<li>一个线程中的所有操作必须按照程序的顺序来执行。</li>
<li>（不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。</li>
</ol>
<h2 id="实际JMM模型"><a href="#实际JMM模型" class="headerlink" title="实际JMM模型"></a>实际JMM模型</h2><p>但是，顺序一致性模型只是一个理想化了的模型，在实际的JMM实现中，为了尽量提高程序运行效率，和理想的顺序一致性内存模型有以下差异：</p>
<p>在顺序一致性模型中，所有操作完全按程序的顺序串行执行。在JMM中不保证单线程操作会按程序顺序执行（即<code>指令重排序</code>）。 顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而JMM不保证所有线程能看到一致的操作执行顺序。 顺序一致性模型保证对所有的内存写操作都具有原子性，而JMM不保证对64位的long型和double型变量的读/写操作具有原子性（分为2个32位写操作进行，本文无关不细阐述）</p>
<h2 id="指令重排序-1"><a href="#指令重排序-1" class="headerlink" title="指令重排序"></a>指令重排序</h2><p>指令重排序是指编译器或处理器为了优化性能而采取的一种手段，在不存在数据依赖性情况下（如写后读，读后写，写后写），调整代码执行顺序。 举个例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//A</span></span><br><span class="line"><span class="keyword">double</span> pi  = <span class="number">3.14</span>;</span><br><span class="line"><span class="comment">//B</span></span><br><span class="line"><span class="keyword">double</span> r   = <span class="number">1.0</span>;</span><br><span class="line"> <span class="comment">//C</span></span><br><span class="line"><span class="keyword">double</span> area = pi * r * r;</span><br></pre></td></tr></table></figure>
<p>这段代码C依赖于A,B，但A，B没有依赖关系，所以代码可能有2种执行顺序：</p>
<ol>
<li>A-&gt;B-&gt;C</li>
<li>B-&gt;A-&gt;C 但无论哪种最终结果都一致，这种满足单线程内无论如何重排序不改变最终结果的语义，被称作<code>as-if-serial语义</code>，遵守as-if-serial语义的编译器，runtime 和处理器共同为编写单线程程序的程序员创建了一个幻觉： 单线程程序是按程序的顺序来执行的。</li>
</ol>
<h2 id="双重检查锁问题解决方案"><a href="#双重检查锁问题解决方案" class="headerlink" title="双重检查锁问题解决方案"></a>双重检查锁问题解决方案</h2><p>回来看下我们出问题的双重检查锁程序，它是满足<code>as-if-serial语义</code>的吗？是的，单线程下它没有任何问题，但是在多线程下，会因为重排序出现问题。</p>
<p>解决方案就是大名鼎鼎的volatile关键字，对于volatile我们最深的印象是它保证了”可见性“，它的”可见性“是通过它的内存语义实现的:</p>
<ul>
<li>写volatile修饰的变量时，JMM会把本地内存中值刷新到主内存</li>
<li>读volatile修饰的变量时，JMM会设置本地内存无效</li>
</ul>
<p>重点：为了实现可见性内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来防止重排序！</p>
<p>对之前代码加入volatile关键字，即可实现线程安全的单例模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单例模式三：DCL(double checked locking)双重校验锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton3 singleton3;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton3 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton3.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton3 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleton3 = <span class="keyword">new</span> Singleton3();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
</blockquote>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/12/15/Blog/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/BlockingQueue%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/">BlockingQueue阻塞队列</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/">java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/BlockingQueue/">BlockingQueue</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/">阻塞队列</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Lock/">Lock</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/ReentrantLock/">ReentrantLock</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Condition/">Condition</a></span><div class="content"><h1 id="BlockingQueue简介"><a href="#BlockingQueue简介" class="headerlink" title="BlockingQueue简介"></a>BlockingQueue简介</h1><p><code>BlockingQueue</code>有一个重要的特征，当生产者线程向<code>BlockingQueue</code>放入元素时，如果队列已满，则生产者线程阻塞；当消费者线程试图向<code>BlockingQueue</code>取元素时，如果队列为空，则需要消费者线程阻塞。</p>
<p>通过两个线程交替的向<code>BlockingQueue</code>放入和读取元素，即可很好地控制线程的通信。</p>
<h2 id="API-简介"><a href="#API-简介" class="headerlink" title="API 简介"></a>API 简介</h2><table>
<thead>
<tr>
<th>API</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>put(E e)</code></td>
<td>尝试将E元素放入BlockingQueue中,如果该队列的元素已满，则阻塞该线程</td>
</tr>
<tr>
<td><code>take()</code></td>
<td>尝试从BlockingQueue中获取元素，如果该队列的元素为空，则阻塞该线程</td>
</tr>
</tbody></table>
<p><code>BlockingQueue</code>不接受 <code>null</code>元素。试图 add、put 或 offer 一个 null 元素时，某些实现会抛 <code>NullPointerException</code>。null 被用作指示 poll 操作失败的警戒值</p>
<hr>
<p><code>BlockingQueue</code>实现了Queue接口。当然也实现了Queue中的接口方法，但是，除了上面两个方法有阻塞功能外，其他的插入和获取都不能引起线程的阻塞。</p>
<p><img src="http://image.icool8.cn/blog/20201215/X8jv7Pk7Otki.png?imageslim" alt="mark"></p>
<ul>
<li>在队列尾部插入元素。 包括 <code>add(E e)</code>、<code>offer(E e)</code> 和 <code>put(E e)</code>方法，当<code>BlockingQueue</code>队列已经满时，三个方法分别会抛出异常，返回false、阻塞队列</li>
<li>在队列头部取数据（或者删除队列头数据），包括remove()、poll() 和 take() ， 当<code>BlockingQueue</code>队列为空时，三个方法分别会抛出异常、返回false、阻塞队列。</li>
</ul></div><a class="more" href="/2019/12/15/Blog/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/BlockingQueue%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/12/12/Blog/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E4%BE%9D%E6%8D%AELock+Condition%E5%AE%9E%E7%8E%B0%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/">依据Lock+Condition实现阻塞队列</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-12</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/">java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/">阻塞队列</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Lock/">Lock</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/ReentrantLock/">ReentrantLock</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Condition/">Condition</a></span><div class="content"><h1 id="非阻塞队列"><a href="#非阻塞队列" class="headerlink" title="非阻塞队列"></a>非阻塞队列</h1><p>代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 普通的队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> jiaxufeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NormalQueue</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The queued items */</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items;</span><br><span class="line">    <span class="comment">/** items index for next take, poll, peek or remove */</span></span><br><span class="line">    <span class="keyword">int</span> takeIndex;</span><br><span class="line">    <span class="comment">/** items index for next put, offer, or add */</span></span><br><span class="line">    <span class="keyword">int</span> putIndex;</span><br><span class="line">    <span class="comment">/** Number of elements in the queue */</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="comment">/** size of the queue */</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NormalQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Object x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span> || count == items.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">        items[putIndex] = x;</span><br><span class="line">        <span class="keyword">if</span> (++putIndex == items.length) &#123;</span><br><span class="line">            putIndex = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">        Object x = items[takeIndex];</span><br><span class="line">        items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (++takeIndex == items.length) &#123;</span><br><span class="line">            takeIndex = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 获取当前队列的元素个数 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>.count&#125;;</span><br><span class="line">    <span class="comment">/** 获取当前队列的长度 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>.size&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><a class="more" href="/2019/12/12/Blog/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E4%BE%9D%E6%8D%AELock+Condition%E5%AE%9E%E7%8E%B0%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/12/07/Blog/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Lock%E7%9A%84lock%E3%80%81tryLock%E3%80%81lockInterruptibly/">Lock的lock、tryLock、lockInterruptibly</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-07</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/">java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Lock/">Lock</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/ReentrantLock/">ReentrantLock</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Condition/">Condition</a></span><div class="content"></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/12/07/Blog/java/%E6%95%B0%E6%8D%AE%E5%BA%93/%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9F%A5%E8%AF%A2%E5%8E%9F%E7%90%86%E5%92%8C%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/">联合索引的查询原理和存储结构</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-07</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/">mysql</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/">二叉树</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/mysql/">mysql</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E7%B4%A2%E5%BC%95/">索引</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/B-Tree/">B-Tree</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/B-Tree/">B+Tree</a></span><div class="content"><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>偶然间翻看一篇关于联合索引结构的博客，发现其对联合索引存储结构的描述是错误的。本篇文章主要阐述下联合索引在B+Tree上的实际存储结构。</p>
<p><strong>本文主要讲解的内容有：</strong></p>
<ul>
<li>联合索引在B+树上的存储结构</li>
<li>联合索引的查找方式</li>
<li>为什么会有最左前缀匹配原则</li>
</ul>
<blockquote>
<p>在分享这篇文章之前，我在网上查了关于MySQL联合索引在B+树上的存储结构这个问题，翻阅了很多博客和技术文章，其中有几篇讲述的与事实相悖。具体如下：</p>
<p>很多博客中都是说：联合索引在B+树上的 <strong>非叶子节点</strong> 中只会存储 联合索引 中的第一个索引字段 的值，联合索引的其余索引字段的值只会出现在 B+树 的 <strong>叶子节点</strong> 中 。（其实这句话是不对的）</p>
</blockquote>
<p>如下图，就是 <strong>错误的</strong> 联合索引的 B+树 存储结构图：</p>
<p><img src="http://image.icool8.cn/blog/20201207/NKkFMaBSiqds.png?imageslim" alt="mark"></p>
<blockquote>
<p>庆幸的是通过查询发现有一条是来自思否社区的关于【联合索引 在 B+Tree 上的存储结构？】问答，有答主回答了这个问题，并贴出了一篇文章和一张图以及一句简单的描述。 <strong>PS：贴出的文章链接已经打不开了</strong> 。</p>
<p>所以在这样的条件下本篇文章就诞生了。</p>
</blockquote>
<h2 id="联合索引存储结构："><a href="#联合索引存储结构：" class="headerlink" title="联合索引存储结构："></a>联合索引存储结构：</h2><p><img src="http://image.icool8.cn/blog/20201207/SWa7Qh49hbAc.png?imageslim" alt="mark"></p>
<p>由于回答只有这么一张图一句话，可能会让大家有点看不懂，所以我们就借助前人的肩膀用这个例子来更加细致的讲探寻一下联合索引在B+树上的存储结构吧。</p>
<p>首先，有一个T1表， 然后表T1有字段a,b,c,d,e，其中a是主键，除e为varchar其余为int类型，并创建了一个联合索引idx_t1_bcd(b,c,d)，然后b、c、d三列作为联合索引，在B+树上的结构正如上图所示。联合索引的所有索引列都出现在索引数上，并依次比较三列的大小。上图树高只有两层不容易理解，下面是假设的表数据以及我对其联合索引在B+树上的结构图的改进。 <strong>PS：基于InnoDB存储引擎。</strong></p>
<p>index（b、c、d）联合索引在B+树上的结构图如下：</p>
<p><img src="http://image.icool8.cn/blog/20201207/bLKmMezWJkAS.png?imageslim" alt="mark"></p>
<p>T1表中的数据如下图：（ <strong>上图 B+树 中的数据就来自下图</strong> ）</p>
<p><img src="http://image.icool8.cn/blog/20201207/wezgbrYzyzMl.png?imageslim" alt="mark"></p>
<blockquote>
<p>通过这俩图我们心里对联合索引在B+树上的存储结构就有了个大概的认识。下面用我的语言为大家解释一下吧。</p>
</blockquote>
<p>我们先看T1表，他的主键暂且我们将它设为整型自增的 ，InnoDB会使用主键索引在B+树维护索引和数据文件，然后我们创建了一个联合索引（b，c，d）也会生成一个索引树，同样是B+树的结构，只不过它的 <strong>data部分</strong> 存储的是联合索引所在行记录的主键值 <strong>（上图叶子节点紫色背景部分）</strong> 。为什么是 主键值，而不是 整个行记录呢？ 因为这个 联合索引 是个 <strong>非聚簇索引</strong> 。</p>
<p>好了大致情况都介绍完了。下面我们结合这俩图来解释一下。</p>
<p>对于联合索引来说只不过比单值索引多了几列，而这些索引列全都出现在索引树上。对于联合索引，存储引擎会首先根据第一个索引列排序，如上图我们可以单看第一个索引列，如，1 1 5 12 13…它是单调递增的；如果第一列相等则再根据第二列排序，依次类推就构成了上图的索引树，上图中的1 1 4 ，1 1 5以及13 12 4, 13 16 1, 13 16 5就可以说明这种情况。</p>
<h2 id="联合索引具体查找步骤："><a href="#联合索引具体查找步骤：" class="headerlink" title="联合索引具体查找步骤："></a>联合索引具体查找步骤：</h2><p>当我们的SQL语言可以应用到索引的时候，比如 select * from T1 where b = 12 and c = 14 and d = 3 ；也就是T1表中a列为4的这条记录。</p>
<p>查找步骤具体如下：</p>
<ol>
<li>存储引擎首先从根节点（一般常驻内存）开始查找，第一个索引的第一个索引列为1,12大于1，第二个索引的第一个索引列为56,12小于56，于是从这俩索引的中间读到下一个节点的磁盘文件地址（此处实际上是存在一个指针的，指向的是下一个节点的磁盘位置）。</li>
<li>进行一次磁盘IO，将此节点值加载后内存中，然后根据第一步一样进行判断，发现 数据都是匹配的，然后根据指针将此联合索引值所在的叶子节点也从磁盘中加载后内存，此时又发生了一次磁盘IO，最终根据叶子节点中索引值关联的 <strong>主键值</strong> 。</li>
<li>根据主键值 <strong>回表</strong> 去主键索引树（聚簇索引）中查询具体的行记录。</li>
</ol>
<p><img src="http://image.icool8.cn/blog/20201207/Qfh7WqY2D7HW.png?imageslim" alt="mark"></p>
<h2 id="联合索引的最左前缀原则："><a href="#联合索引的最左前缀原则：" class="headerlink" title="联合索引的最左前缀原则："></a>联合索引的最左前缀原则：</h2><blockquote>
<p>之所以会有最左前缀匹配原则和联合索引的索引构建方式及存储结构是有关系的。</p>
</blockquote>
<p>首先我们创建的idx_t1_bcd(b,c,d)索引，相当于创建了(b)、（b、c）（b、c、d）三个索引，看完下面你就知道为什么相当于创建了三个索引。</p>
<p>我们看，联合索引是首先使用多列索引的第一列构建的索引树，用上面idx_t1_bcd(b,c,d)的例子就是优先使用b列构建，当b列值相等时再以c列排序，若c列的值也相等则以d列排序。我们可以取出索引树的叶子节点看一下。</p>
<p><img src="http://image.icool8.cn/blog/20201207/UdfMTEv0iWQv.png?imageslim" alt="mark"></p>
<p>索引的第一列也就是b列可以说是从左到右单调递增的，但我们看c列和d列并没有这个特性，它们只能在b列值相等的情况下这个小范围内递增，如第一叶子节点的第1、2个元素和第二个叶子节点的后三个元素。<br>​<br>由于联合索引是上述那样的索引构建方式及存储结构，所以联合索引只能从多列索引的第一列开始查找。所以如果你的查找条件不包含b列如（c,d）、(c）、(d)是无法应用缓存的，以及跨列也是无法完全用到索引如(b,d)，只会用到b列索引。</p>
<p>这就像我们的电话本一样，有名和姓以及电话，名和姓就是联合索引。在姓可以以姓的首字母排序，姓的首字母相同的情况下，再以名的首字母排序。</p>
<p><strong>如：</strong></p>
<blockquote>
<p>M<br>毛 不易   178**<strong>**</strong><br>马 化腾   183**<strong>**</strong><br>马 云     188**<strong>**</strong><br>Z<br>张 杰     189**<strong>**</strong><br>张 靓颖   138**<strong>**</strong><br>张 艺兴   176**<strong>**</strong>  </p>
</blockquote>
<p>我们知道名和姓是很快就能够从姓的首字母索引定位到姓，然后定位到名，进而找到电话号码，因为所有的姓从上到下按照既定的规则（首字母排序）是有序的，而名是在姓的首字母一定的条件下也是按照名的首字母排序的，但是整体来看，所有的名放在一起是无序的，所以如果只知道名查找起来就比较慢，因为无法用已排好的结构快速查找。</p>
<p>到这里大家是否明白了为啥会有最左前缀匹配原则了吧。</p>
<h2 id="实践："><a href="#实践：" class="headerlink" title="实践："></a>实践：</h2><p>如下列举一些SQL的索引使用情况：</p>
<blockquote>
<p>select * from T1 where b = 12 and c = 14 and d = 3;<em>– 全值索引匹配 三列都用到</em><br>select * from T1 where b = 12 and c = 14 and e = ‘xml’;<em>– 应用到两列索引</em><br>select * from T1 where b = 12 and e = ‘xml’;<em>– 应用到一列索引</em><br>select * from T1 where b = 12  and c &gt;= 14 and e = ‘xml’;<em>– 应用到一列索引及索引条件下推优化</em><br>select * from T1 where b = 12  and d = 3;<em>– 应用到一列索引  因为不能跨列使用索引 没有c列 连不上</em><br>select * from T1 where c = 14  and d = 3;<em>– 无法应用索引，违背最左匹配原则</em></p>
</blockquote>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/11/29/Blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/HashMap%E3%80%81HashTable%E3%80%81ConcurrentHashMap%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D/">HashMap、HashTable、ConcurrentHashMap详细介绍</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-11-29</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/HashMap/">HashMap</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/HashTable/">HashTable</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/ConcurrentHashMap/">ConcurrentHashMap</a></span><div class="content"><h2 id="一、什么是哈希表"><a href="#一、什么是哈希表" class="headerlink" title="一、什么是哈希表"></a>一、什么是哈希表</h2><p>在讨论哈希表之前，我们先大概了解下其他数据结构在新增，查找等基础操作执行性能</p>
<ul>
<li>数组<br>采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)；<br>通过给定值进行查找，需要遍历数组，逐一比对给定关键字和数组元素，时间复杂度为O(n)，当然，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为O(logn)；<br>对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为O(n)</li>
<li>线性链表<br>对于链表的新增，删除等操作（在找到指定操作位置后），仅需处理结点间的引用即可，时间复杂度为O(1)，而查找操作需要遍历链表逐一进行比对，复杂度为O(n)</li>
<li>二叉树<br>对一棵相对平衡的有序二叉树，对其进行插入，查找，删除等操作，平均复杂度均为O(logn)。</li>
<li>哈希表<br>相比上述几种数据结构，在哈希表中进行添加，删除，查找等操作，性能十分之高，不考虑哈希冲突的情况下，仅需一次定位即可完成，时间复杂度为O(1).</li>
</ul></div><a class="more" href="/2019/11/29/Blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/HashMap%E3%80%81HashTable%E3%80%81ConcurrentHashMap%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/11/12/Blog/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/AbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">AbstractQueuedSynchronizer源码分析</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-11-12</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/">java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Lock/">Lock</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/ReentrantLock/">ReentrantLock</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/AbstractQueuedSynchronizer/">AbstractQueuedSynchronizer</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/AQS/">AQS</a></span><div class="content"><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>AbstractQueuedSynchronizer，顾名思义，是一个基于队列Queued实现的同步锁，就是我们讨论java多线程时常说的<strong>AQS</strong>。</p></div><a class="more" href="/2019/11/12/Blog/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/AbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/09/17/Blog/python/python%E6%93%8D%E4%BD%9Cexcel/">python操作excel</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-09-17</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/python/">python</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/excel/">excel</a></span><div class="content"><p>openpyxl</p>
<p>通过openpyxl可以操作excel</p>
<p>首先理解几个基本概念，Excel文件三个对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">workbook： 工作簿，就是一个虚拟excel</span><br><span class="line">sheet：工作表，一个workbook文件包含多个sheet。，如“sheet1”,“sheet2”等。</span><br><span class="line">row：行，一个sheet有多个行</span><br><span class="line">column：列，一个sheet有多个列</span><br><span class="line">cell： 单元格，一行有多个单元格</span><br></pre></td></tr></table></figure>
<p>1、如果没有安装openpyxl模块，可以通过pip安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install openpyxl</span><br></pre></td></tr></table></figure>
<p>2、导入Workbook</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> Workbook,load_workbook</span><br></pre></td></tr></table></figure>
<p>3、创建Workbook</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wb = Workbook() <span class="comment">#表不存在，创建</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>创建后,可以通过<code>Workbook.active</code>属性来定位到工作表，该工作簿的默认索引是从0开始。除非索引值被修改，否则使用这个方法将总是获取第一个工作表。</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ws = wb.active</span><br></pre></td></tr></table></figure>
<p>4、读取Workbook</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wb = load_workbook(<span class="string">&#x27;test.xlsx&#x27;</span>)<span class="comment">#表存在，导入</span></span><br></pre></td></tr></table></figure></div><a class="more" href="/2019/09/17/Blog/python/python%E6%93%8D%E4%BD%9Cexcel/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/08/23/Blog/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/ReentrantLock%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">ReentrantLock源码分析</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-08-23</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/">java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Lock/">Lock</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/ReentrantLock/">ReentrantLock</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Condition/">Condition</a></span><div class="content"><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>java.util.concurrent.locks.ReentrantLock是java并发包concurrent下的一个同步锁实现，ReentrantLock 类实现了 Lock 接口，并扩展了其功能，支持公平锁和非公平锁，ReentrantLock 常与concurrent包下的Condition一起搭配使用（类比Synchronized关键字和Object.wait()、Object.notify()）,基于ReentrantLock 和 Condition的典型实现-BlockingQueue阻塞队列。</p>
<p>ReentrantLock 与Synchronized的不同</p>
<ul>
<li>synchronized是native方法，而Lock是基于java API实现的。</li>
<li>synchronized粒度粗，没有Lock灵活，Lock提供了更多的API。</li>
<li>synchronized 不支持公平锁</li>
<li>synchronized的waiting线程无法处理被中断后的操作，而Lock API提供了<strong>lockInterruptibly()</strong> 方法，可以使被中断现线程抛出一个<strong>InterruptedException</strong>异常，从而可以通过捕获该异常来处理线程中断后的操作。</li>
<li>ReentrantLock 的wait是基于Condition的，通过newCondition()返回与当前lock绑定的Condition，需要等待的时候使用Condition的await()方法, 唤醒的时候用signal()方法，不同的线程使用不同的Condition, 这样就能区分唤醒的时候找哪个线程了，而synchronized是随机唤醒线程的。</li>
</ul></div><a class="more" href="/2019/08/23/Blog/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/ReentrantLock%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/08/13/Blog/java/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%BC%BA%E4%B8%80%E8%87%B4%E6%80%A7/">如何保证缓存和数据库的强一致性</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-08-13</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E7%BC%93%E5%AD%98/">缓存</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E7%BC%93%E5%AD%98/">缓存</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E4%B8%80%E8%87%B4%E6%80%A7/">一致性</a></span><div class="content"><h2 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a><strong>一致性</strong></h2><h3 id="场景介绍"><a href="#场景介绍" class="headerlink" title="场景介绍**"></a>场景介绍**</h3><p>对于用户的余额信息表account(uid, money)，业务上的需求是：</p>
<p>（1）查询用户的余额，SELECT money FROM account WHERE uid=XXX，占99%的请求</p>
<p>（2）更改用户余额，UPDATE account SET money=XXX WHERE uid=XXX，占1%的请求</p>
<p><img src="https://images2015.cnblogs.com/blog/285763/201603/285763-20160317093358459-1991638356.png" alt="img"><br>由于大部分的请求是查询，我们在缓存中建立uid到money的键值对，能够极大降低数据库的压力。</p>
<p>当数据money发生变化的时候：</p>
<p>（1）是更新缓存中的数据，还是淘汰缓存中的数据呢？</p>
<p>（2）是先操纵数据库中的数据再操纵缓存中的数据，还是先操纵缓存中的数据再操纵数据库中的数据呢？</p>
<p>（3）缓存与数据库的操作，在架构上是否有优化的空间呢？</p>
<p>这是本文关注的三个核心问题。</p>
<h3 id="更新缓存-VS-淘汰缓存"><a href="#更新缓存-VS-淘汰缓存" class="headerlink" title="更新缓存 VS 淘汰缓存"></a><strong>更新缓存</strong> <strong>VS</strong> <strong>淘汰缓存</strong></h3><p>什么是更新缓存：数据不但写入数据库，还会写入缓存</p>
<p>什么是淘汰缓存：数据只会写入数据库，不写入缓存，只把缓存数据淘汰掉</p></div><a class="more" href="/2019/08/13/Blog/java/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%BC%BA%E4%B8%80%E8%87%B4%E6%80%A7/#more">Read more</a><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By Jia Xufeng</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>