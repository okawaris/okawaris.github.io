<!DOCTYPE html><html lang="zh-tw"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="根据红黑树的算法来分析TreeMap的实现"><meta name="keywords" content="TreeMap,红黑树"><meta name="author" content="Jia Xufeng"><meta name="copyright" content="Jia Xufeng"><title>根据红黑树的算法来分析TreeMap的实现 | 暗夜精灵のBlog</title><link rel="shortcut icon" href="http://image.icool8.cn/blog/20200618/tlIPrUJYHhnI.png?imageslim"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 5.3.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">红黑树的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TreeMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">TreeMap数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TreeMap-put-%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text">TreeMap put()方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TreeMap-put-%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">2.1.1.</span> <span class="toc-text">TreeMap put()方法分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TreeMap-put-%E4%BB%A3%E7%A0%81"><span class="toc-number">2.1.2.</span> <span class="toc-text">TreeMap put()代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TreeMap-delete-%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.3.</span> <span class="toc-text">TreeMap delete()方法</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="http://image.icool8.cn/blog/20200618/tlIPrUJYHhnI.png?imageslim"></div><div class="author-info__name text-center">Jia Xufeng</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">85</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">83</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">29</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">暗夜精灵のBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">根据红黑树的算法来分析TreeMap的实现</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-03-27</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/java/">java</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="红黑树的概念"><a href="#红黑树的概念" class="headerlink" title="红黑树的概念"></a>红黑树的概念</h2><p>红黑树又称红-黑二叉树，它首先是一颗二叉树，它具体二叉树所有的特性。同时红黑树更是一颗自平衡的排序二叉树。</p>
<p>我们知道一颗基本的二叉树他们都需要满足一个基本性质–即树中的任何节点的值大于它的左子节点，且小于它的右子节点。按照这个基本性质使得树的检索效率大大提高。我们知道在生成二叉树的过程是非常容易失衡的，最坏的情况就是一边倒（只有右/左子树），这样势必会导致二叉树的检索效率大大降低（O(n)），所以为了维持二叉树的平衡，大牛们提出了各种实现的算法，如：<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/414610.htm">AVL</a>，<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/2957252.htm">SBT</a>，<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/1118088.htm">伸展树</a>，<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/956602.htm">TREAP</a> ，<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/133754.htm?fr=aladdin#1_1">红黑树</a>等等。</p>
<p>平衡二叉树必须具备如下特性：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。也就是说该二叉树的任何一个等等子节点，其左右子树的高度都相近。</p>
<a id="more"></a>

<p><img src="http://image.icool8.cn/blog/20201203/wIpePBOPWfSS.png?imageslim" alt="mark"></p>
<p>红黑树顾名思义就是节点是红色或者黑色的平衡二叉树，它通过颜色的约束来维持着二叉树的平衡。对于一棵有效的红黑树二叉树而言我们必须增加如下规则：</p>
<p><strong>1、每个节点都只能是红色或者黑色</strong></p>
<p><strong>2、根节点是黑色</strong></p>
<p><strong>3、每个叶节点（NIL节点，空节点）是黑色的。</strong></p>
<p><strong>4、如果一个结点是红的，则它两个子节点都是黑的。也就是说在一条路径上不能出现相邻的两个红色结点。</strong></p>
<p><strong>5、从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</strong></p>
<p>这些约束强制了红黑树的关键性质: 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这棵树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。所以红黑树它是复杂而高效的，其检索效率O(log <em>n</em>)。下图为一颗典型的红黑二叉树。</p>
<p><img src="http://image.icool8.cn/blog/20201203/x8Yaa3pVOwa8.png?imageslim" alt="mark"></p>
<p>对于红黑二叉树而言它主要包括三大基本操作：<strong>左旋</strong>、<strong>右旋</strong>、<strong>着色</strong>。</p>
<p>TreeMap的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">NavigableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://images0.cnblogs.com/blog/381060/201405/222222286844448.gif"><img src="https://images0.cnblogs.com/blog/381060/201405/222222304812633.gif" alt="2014051700004"></a>                          <a target="_blank" rel="noopener" href="https://images0.cnblogs.com/blog/381060/201405/222222341218286.gif"><img src="https://images0.cnblogs.com/blog/381060/201405/222222354347786.gif" alt="2014051700005"></a></p>
<p>​                                    左旋                                                                                        右旋</p>
<p><strong>注：</strong>由于本文主要是讲解Java中TreeMap，所以并没有对红黑树进行非常深入的了解和研究，如果诸位想对其进行更加深入的研究提供几篇较好的博文：</p>
<p><strong>1、红黑树系列集锦</strong></p>
<p><strong>2、</strong><a target="_blank" rel="noopener" href="http://www.cnblogs.com/fanzhidongyzby/p/3187912.html"><strong>红黑树数据结构剖析</strong></a></p>
<p><strong>3、</strong><a target="_blank" rel="noopener" href="http://blog.csdn.net/eric491179912/article/details/6179908"><strong>红黑树</strong></a></p>
<p><strong>4、红黑树(一)之 原理和算法详细介绍</strong></p>
<h2 id="TreeMap数据结构"><a href="#TreeMap数据结构" class="headerlink" title="TreeMap数据结构"></a>TreeMap数据结构</h2><p>TreeMap的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">NavigableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
<p>TreeMap与Map关系如下图：</p>
<p><img src="http://image.icool8.cn/blog/20201203/NemdtJQ6umLd.png?imageslim" alt="mark"></p>
<p>从图中可以看出：</p>
<ul>
<li>TreeMap实现继承于AbstractMap，并且实现了NavigableMap接口。</li>
<li>TreeMap的本质是R-B Tree(红黑树)，它包含几个重要的成员变量： root, size, comparator。</li>
<li>root 是红黑数的根节点。它是Entry类型，Entry是红黑数的节点，它包含了红黑数的6个基本组成成分：key(键)、value(值)、left(左孩子)、right(右孩子)、　　　　parent(父节点)、color(颜色)。Entry节点根据key进行排序，Entry节点包含的内容为value。</li>
<li>红黑数排序时，根据Entry中的key进行排序；Entry中的key比较大小是根据比较器comparator来进行判断的。size是红黑数中节点的个数。</li>
</ul>
<p>TreeMap继承AbstractMap，实现NavigableMap、Cloneable、Serializable三个接口。其中AbstractMap表明TreeMap为一个Map即支持key-value的集合， NavigableMap（<a target="_blank" rel="noopener" href="http://docs.oracle.com/javase/7/docs/api/java/util/NavigableMap.html">更多</a>）则意味着它支持一系列的导航方法，具备针对给定搜索目标返回最接近匹配项的导航方法 。</p>
<p>TreeMap中同时也包含了如下几个重要的属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比较器，因为TreeMap是有序的，通过comparator接口我们可以对TreeMap的内部排序进行精密的控制</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> K&gt; comparator;</span><br><span class="line"><span class="comment">//TreeMap红-黑节点，为TreeMap的内部类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//容器大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//TreeMap修改次数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//红黑树的节点颜色--红色</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> RED = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//红黑树的节点颜色--黑色</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> BLACK = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>
<p>对于叶子节点Entry是TreeMap的内部类，它有几个重要的属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//键</span></span><br><span class="line">K key;</span><br><span class="line"><span class="comment">//值</span></span><br><span class="line">V value;</span><br><span class="line"><span class="comment">//左孩子</span></span><br><span class="line">Entry&lt;K,V&gt; left = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//右孩子</span></span><br><span class="line">Entry&lt;K,V&gt; right = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//父亲</span></span><br><span class="line">Entry&lt;K,V&gt; parent;</span><br><span class="line"><span class="comment">//颜色</span></span><br><span class="line"><span class="keyword">boolean</span> color = BLACK;    </span><br></pre></td></tr></table></figure>
<p>在下面两节我将重点讲解treeMap的put()、delete()方法。通过这两个方法我们会了解红黑树增加、删除节点的核心算法。</p>
<p><img src="http://image.icool8.cn/blog/20201203/SaPPfrq5V395.png?imageslim" alt="mark"></p>
<h3 id="TreeMap-put-方法"><a href="#TreeMap-put-方法" class="headerlink" title="TreeMap put()方法"></a>TreeMap put()方法</h3><h4 id="TreeMap-put-方法分析"><a href="#TreeMap-put-方法分析" class="headerlink" title="TreeMap put()方法分析"></a>TreeMap put()方法分析</h4><p>在了解TreeMap的put()方法之前，我们先了解红黑树增加节点的算法。</p>
<p>红黑树在新增节点过程中比较复杂，复杂归复杂它同样必须要依据上面提到的五点规范，同时由于规则1、2、3基本都会满足，下面我们主要讨论规则4、5。假设我们这里有一棵最简单的树，我们规定新增的节点为N、它的父节点为P、P的兄弟节点为U、P的父节点为G。</p>
<p>对于新节点的插入有如下三个关键地方：</p>
<p>1、插入新节点总是红色节点 。<br>2、如果插入节点的父节点是黑色, 能维持性质 。<br>3、如果插入节点的父节点是红色, 破坏了性质. 故插入算法就是通过重新着色或旋转, 来维持性质 。<br>为了保证下面的阐述更加清晰和根据便于参考，我这里将红黑树的五点规定再贴一遍：</p>
<ul>
<li><p><strong>每个节点都只能是红色或者黑色</strong></p>
</li>
<li><p><strong>根节点是黑色</strong></p>
</li>
<li><p><strong>每个叶节点（NIL节点，空节点）是黑色的。</strong></p>
</li>
<li><p><strong>如果一个结点是红的，则它两个子节点都是黑的。也就是说在一条路径上不能出现相邻的两个红色结点。</strong></p>
</li>
<li><p><strong>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</strong></p>
</li>
</ul>
<p><strong>一、被插入的节点是根节点。</strong></p>
<p>若新插入的节点N没有父节点，则直接当做根据节点插入即可，同时将颜色设置为黑色。（如图一（1））</p>
<p><strong>二、被插入的节点的父节点是黑色。</strong></p>
<p>这种情况新节点N同样是直接插入，同时颜色为红色，由于根据规则四它会存在两个黑色的叶子节点，值为null。同时由于新增节点N为红色，所以通过它的子节点的路径依然会保存着相同的黑色节点数，同样满足规则5。（如图一（2））</p>
<p><img src="http://image.icool8.cn/blog/20201203/dQcsCIExzbKw.png?imageslim" alt="mark"></p>
<p><strong>三、被插入的节点的父节点是红色。</strong></p>
<p>穷举下一下几类，就可以画出下面的情况：</p>
<p><img src="http://image.icool8.cn/blog/20201203/cBnG5UNekOG6.png?imageslim" alt="mark"></p>
<p>对于上述五种情况，列表给出每种的解决方法：</p>
<p><img src="http://image.icool8.cn/blog/20201203/YlrNX2g25PJJ.png?imageslim" alt="mark"></p>
<p>上面展示了红黑树新增节点的五种情况，这五种情况涵盖了所有的新增可能，不管这棵红黑树多么复杂，都可以根据这五种情况来进行生成。下面就来分析Java中的TreeMap是如何来实现红黑树的。</p>
<p> 下面图表示：</p>
<p><img src="http://image.icool8.cn/blog/20201203/kU4k4OxPGL95.png?imageslim" alt="mark"></p>
<h4 id="TreeMap-put-代码"><a href="#TreeMap-put-代码" class="headerlink" title="TreeMap put()代码"></a>TreeMap put()代码</h4><p>在TreeMap的put()的实现方法中主要分为两个步骤，第一：构建排序二叉树，第二：平衡二叉树。</p>
<p>对于排序二叉树的创建，其添加节点的过程如下：</p>
<p>1、以根节点为初始节点进行检索。</p>
<p>2、与当前节点进行比对，若新增节点值较大，则以当前节点的右子节点作为新的当前节点。否则以当前节点的左子节点作为新的当前节点。</p>
<p>3、循环递归2步骤知道检索出合适的叶子节点为止。</p>
<p>4、将新增节点与3步骤中找到的节点进行比对，如果新增节点较大，则添加为右子节点；否则添加为左子节点。</p>
<p>按照这个步骤我们就可以将一个新增节点添加到排序二叉树中合适的位置。如下：</p>
<p>public V put(K key, V value) {<br>                //用t表示二叉树的当前节点<br>        Entry&lt;K,V&gt; t = root;<br>        //t为null表示一个空树，即TreeMap中没有任何元素，直接插入<br>        if (t == null) {<br>            compare(key, key); // type (and possibly null) check</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//将新的key-value键值对创建为一个Entry节点，并将该节点赋予给root</span></span><br><span class="line">    root = <span class="keyword">new</span> Entry&lt;&gt;(key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//容器的size = 1，表示TreeMap集合中存在一个元素</span></span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//修改次数 + 1</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cmp表示key排序的返回结果</span></span><br><span class="line"><span class="keyword">int</span> cmp;</span><br><span class="line">Entry&lt;K,V&gt; parent; <span class="comment">//父节点</span></span><br><span class="line"><span class="comment">// split comparator and comparable paths</span></span><br><span class="line"><span class="comment">//指定的排序算法</span></span><br><span class="line">Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</span><br><span class="line"><span class="comment">//如果cpr不为空，则采用既定的排序算法进行创建TreeMap集合</span></span><br><span class="line"><span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        parent = t;<span class="comment">//parent指向上次循环后的t</span></span><br><span class="line">        <span class="comment">//比较新增节点的key和当前节点key的大小</span></span><br><span class="line">        cmp = cpr.compare(key, t.key);</span><br><span class="line">        <span class="comment">//cmp返回值小于0，表示新增节点的key小于当前节点的key，则以当前节点的左子节点作为新的当前节点</span></span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            t = t.left;</span><br><span class="line">            <span class="comment">//cmp返回值大于0，表示新增节点的key大于当前节点的key，则以当前节点的右子节点作为新的当前节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            t = t.right;</span><br><span class="line">            <span class="comment">//cmp返回值等于0，表示两个key值相等，则新值覆盖旧值，并返回新值</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">    &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果cpr为空，则采用默认的排序算法进行创建TreeMap集合</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//key值为空抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//下面处理过程和上面一样</span></span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        parent = t;</span><br><span class="line">        cmp = k.compareTo(t.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            t = t.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            t = t.right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">    &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将新增节点当做parent的子节点</span></span><br><span class="line">Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(key, value, parent);</span><br><span class="line"><span class="comment">//如果新增节点的key小于parent的key，则当做左子节点</span></span><br><span class="line"><span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">    parent.left = e;</span><br><span class="line"><span class="comment">//如果新增节点的key大于parent的key，则当做右子节点</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    parent.right = e;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 上面已经完成了排序二叉树的的构建，将新增节点插入该树中的合适位置</span></span><br><span class="line"><span class="comment"> * 下面fixAfterInsertion()方法就是对这棵树进行调整、平衡，具体过程参考上面的五种情况</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">fixAfterInsertion(e);</span><br><span class="line"><span class="comment">//TreeMap元素数量 + 1</span></span><br><span class="line">size++;</span><br><span class="line"><span class="comment">//TreeMap容器修改次数 + 1</span></span><br><span class="line">modCount++;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面代码中do{}代码块是实现排序二叉树的核心算法，通过该算法我们可以确认新增节点在该树的正确位置。找到正确位置后将插入即可，这样做了其实还没有完成，因为我知道TreeMap的底层实现是红黑树，红黑树是一棵平衡排序二叉树，普通的排序二叉树可能会出现失衡的情况，所以下一步就是要进行调整。<strong>fixAfterInsertion(e)</strong>; 调整的过程务必会涉及到红黑树的左旋、右旋、着色三个基本操作。代码如下：</p>
<p>private void fixAfterInsertion(Entry&lt;K,V&gt; x) {<br>                 //新增节点的颜色为红色<br>        x.color = RED;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span> (x != <span class="keyword">null</span> &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123;</span><br><span class="line">            <span class="comment">//如果X的父节点（P）是其祖父节点（G）的左节点</span></span><br><span class="line">        <span class="keyword">if</span> (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123;</span><br><span class="line">                <span class="comment">//获取X的叔节点y(U)</span></span><br><span class="line">            Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));</span><br><span class="line">            <span class="comment">//如果X的叔节点（U） 为红色（case1）</span></span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                    <span class="comment">//将“父节点”设为黑色。</span></span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                <span class="comment">//将“叔叔节点”设为黑色。</span></span><br><span class="line">                setColor(y, BLACK);</span><br><span class="line">                <span class="comment">//将“祖父节点”设为红色。</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                <span class="comment">//将“祖父节点”设为“当前节点”(红色节点)</span></span><br><span class="line">                x = parentOf(parentOf(x));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果X的叔节点（U） 为黑色</span></span><br><span class="line">                    <span class="comment">//如果X节点为其父节点（P）的右子树，则进行左旋转</span></span><br><span class="line">                <span class="keyword">if</span> (x == rightOf(parentOf(x))) &#123;</span><br><span class="line">                        <span class="comment">//将X的父节点作为X</span></span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                    <span class="comment">//左旋转</span></span><br><span class="line">                    rotateLeft(x);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将X的父节点（P）设置为黑色</span></span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                <span class="comment">//将X的祖父节点（G）设置红色</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                <span class="comment">//以X的祖父节点（G）为中心右旋转</span></span><br><span class="line">                rotateRight(parentOf(parentOf(x)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果X的父节点（P）是其父节点的父节点（G）的右节点</span></span><br><span class="line">            <span class="comment">//获取X的叔节点y（U）</span></span><br><span class="line">            Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));</span><br><span class="line">            <span class="comment">//如果X的叔节点（U） 为红色</span></span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                <span class="comment">//将X的父节点（P）设置为黑色</span></span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                <span class="comment">//将X的叔节点（U）设置为黑色</span></span><br><span class="line">                setColor(y, BLACK);</span><br><span class="line">                <span class="comment">//将X的祖父节点（G）设置红色</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                <span class="comment">//x设为x的祖父节点</span></span><br><span class="line">                x = parentOf(parentOf(x));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果X的叔节点（U为黑色</span></span><br><span class="line">             <span class="comment">//如果X节点为其父节点（P）的左子树</span></span><br><span class="line">                <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">                    <span class="comment">//将X的父节点作为X</span></span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                    <span class="comment">//右旋转</span></span><br><span class="line">                    rotateRight(x);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将X的父节点（P）设置为黑色</span></span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                 <span class="comment">//将X的祖父节点（G）设置红色</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                <span class="comment">//以X的祖父点（G）为中心左旋转</span></span><br><span class="line">                rotateLeft(parentOf(parentOf(x)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将根节点G强制设置为黑色</span></span><br><span class="line">    root.color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对这段代码的研究我们发现,其处理过程完全符合红黑树新增节点的处理过程。所以在看这段代码的过程一定要对红黑树的新增节点过程有了解。在这个代码中还包含几个重要的操作。左旋(rotateLeft())、右旋（rotateRight()）、着色（setColor()）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotateLeft</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//获取P的右子节点，其实这里就相当于新增节点N</span></span><br><span class="line">            Entry&lt;K,V&gt; r = p.right;</span><br><span class="line">            <span class="comment">//将R的左子树设置为P的右子树</span></span><br><span class="line">            p.right = r.left;</span><br><span class="line">            <span class="comment">//若R的左子树不为空，则将P设置为R左子树的父亲</span></span><br><span class="line">            <span class="keyword">if</span> (r.left != <span class="keyword">null</span>)</span><br><span class="line">                r.left.parent = p;</span><br><span class="line">            <span class="comment">//将P的父亲设置R的父亲</span></span><br><span class="line">            r.parent = p.parent;</span><br><span class="line">            <span class="comment">//如果P的父亲为空，则将R设置为跟节点</span></span><br><span class="line">            <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">                root = r;</span><br><span class="line">            <span class="comment">//如果P为其父节点（G）的左子树，则将R设置为P父节点(G)左子树</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p.parent.left == p)</span><br><span class="line">                p.parent.left = r;</span><br><span class="line">            <span class="comment">//否则R设置为P的父节点（G）的右子树</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.parent.right = r;</span><br><span class="line">            <span class="comment">//将P设置为R的左子树</span></span><br><span class="line">            r.left = p;</span><br><span class="line">            <span class="comment">//将R设置为P的父节点</span></span><br><span class="line">            p.parent = r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p> <strong>右旋：rotateRight()</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotateRight</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//将L设置为P的左子树</span></span><br><span class="line">            Entry&lt;K,V&gt; l = p.left;</span><br><span class="line">            <span class="comment">//将L的右子树设置为P的左子树</span></span><br><span class="line">            p.left = l.right;</span><br><span class="line">            <span class="comment">//若L的右子树不为空，则将P设置L的右子树的父节点</span></span><br><span class="line">            <span class="keyword">if</span> (l.right != <span class="keyword">null</span>) l.right.parent = p;</span><br><span class="line">            <span class="comment">//将P的父节点设置为L的父节点</span></span><br><span class="line">            l.parent = p.parent;</span><br><span class="line">            <span class="comment">//如果P的父节点为空，则将L设置根节点</span></span><br><span class="line">            <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">                root = l;</span><br><span class="line">            <span class="comment">//若P为其父节点的右子树，则将L设置为P的父节点的右子树</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p.parent.right == p)</span><br><span class="line">                p.parent.right = l;</span><br><span class="line">            <span class="comment">//否则将L设置为P的父节点的左子树</span></span><br><span class="line">            <span class="keyword">else</span> p.parent.left = l;</span><br><span class="line">            <span class="comment">//将P设置为L的右子树</span></span><br><span class="line">            l.right = p;</span><br><span class="line">            <span class="comment">//将L设置为P的父节点</span></span><br><span class="line">            p.parent = l;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>左旋、右旋的示意图如下：</p>
<p><a target="_blank" rel="noopener" href="https://images0.cnblogs.com/blog/381060/201405/222222411684067.gif"><img src="https://images0.cnblogs.com/blog/381060/201405/222222425437080.gif" alt="2014051700004"></a>                              <a target="_blank" rel="noopener" href="https://images0.cnblogs.com/blog/381060/201405/222222438249121.gif"><img src="https://images0.cnblogs.com/blog/381060/201405/222222452156364.gif" alt="2014051700005"></a></p>
<p>​                                （左旋）                                                                                     （右旋）</p>
<p><strong>着色：setColor()</strong> </p>
<p>着色就是改变该节点的颜色，在红黑树中，它是依靠节点的颜色来维持平衡的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">setColor</span><span class="params">(Entry&lt;K,V&gt; p, <span class="keyword">boolean</span> c)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="keyword">null</span>)</span><br><span class="line">           p.color = c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="TreeMap-delete-方法"><a href="#TreeMap-delete-方法" class="headerlink" title="TreeMap delete()方法"></a>TreeMap delete()方法</h4><p>TreeMap delete()方法分析</p>
<p>针对于红黑树的增加节点而言，删除显得更加复杂，使原本就复杂的红黑树变得更加复杂。同时删除节点和增加节点一样，同样是找到删除的节点，删除之后调整红黑树。但是这里的删除节点并不是直接删除，而是通过走了“弯路”通过一种捷径来删除的：<strong>找到被删除的节点D的子节点F，用F来替代D，不是直接删除D，因为D被F替代了，直接删除F即可。</strong>所以这里就将删除父节点D的事情转变为了删除子节点F的事情，这样处理就将复杂的删除事件简单化了。<strong>子节点F的规则是：如果有右分支，则是右分支最左边，否则，是左分支最右边的。</strong></p>
<p>红-黑二叉树删除节点，最大的麻烦是要保持 各分支黑色节点数目相等。 因为是删除，所以不用担心存在颜色冲突问题——插入才会引起颜色冲突。</p>
<p>红黑树删除节点同样会分成几种情况，这里是按照待删除节点有几个儿子的情况来进行分类：</p>
<p>1、没有儿子，即为叶结点。直接把父结点的对应儿子指针设为NULL，删除儿子结点就OK了。</p>
<p>2、只有一个儿子。那么把父结点的相应儿子指针指向儿子的独生子，删除儿子结点也OK了。</p>
<p>3、有两个儿子。这种情况比较复杂，但还是比较简单。上面提到过用子节点C替代代替待删除节点D，然后删除子节点C即可。</p>
<p>下面就论各种删除情况来进行图例讲解，<strong>请时刻牢记红黑树的5点规定：</strong></p>
<p><strong>1、每个节点都只能是红色或者黑色</strong></p>
<p><strong>2、根节点是黑色</strong></p>
<p><strong>3、每个叶节点（NIL节点，空节点）是黑色的。</strong></p>
<p><strong>4、如果一个结点是红的，则它两个子节点都是黑的。也就是说在一条路径上不能出现相邻的两个红色结点。</strong></p>
<p><strong>5、从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</strong></p>
<p>删除节点比较复杂，那么在这里我们就约定一下规则：</p>
<p>1、下面要讲解的删除节点一定是实际要删除节点的后继节点（N），如前面提到的C。</p>
<p>2、下面提到的删除节点的树都是如下结构，该结构所选取的节点是待删除节点的右树的最左边子节点。这里我们规定真实删除节点为N、父节点为P、兄弟节点为W兄弟节点的两个子节点为X1、X2。如下图（2.1）。</p>
<p><strong><img src="https://images0.cnblogs.com/blog/381060/201405/222222487938503.png" alt="20140517000013"></strong></p>
<p>现在我们就上面提到的三种情况进行分析、处理。</p>
<p><strong>情况一、无子节点（红色节点）</strong></p>
<p>这种情况对该节点直接删除即可，不会影响树的结构。因为该节点为叶子节点它不可能存在子节点—–如子节点为黑，则违反黑节点数原则（规定5），为红，则违反“颜色”原则（规定4）。 如上图（2.2）。</p>
<p><strong>情况二、有一个子节点</strong></p>
<p>这种情况处理也是非常简单的，用子节点替代待删除节点，然后删除子节点即可。如上图（2.3）</p>
<p><strong>情况三、有两个子节点</strong></p>
<p>这种情况可能会稍微有点儿复杂。它需要找到一个替代待删除节点（N）来替代它，然后删除N即可。它主要分为四种情况。</p>
<p>1、N的兄弟节点W为红色</p>
<p>2、N的兄弟w是黑色的，且w的俩个孩子都是黑色的。</p>
<p>3、N的兄弟w是黑色的，w的左孩子是红色，w的右孩子是黑色。</p>
<p>4、N的兄弟w是黑色的，且w的右孩子时红色的。</p>
<p><strong>情况3.1、N的兄弟节点W为红色</strong></p>
<p>W为红色，那么其子节点X1、X2必定全部为黑色，父节点P也为黑色。</p>
<p>处理策略是：(01) 将x的兄弟节点W设为“黑色”。(02) 将x的父节点P设为“红色”。(03) 对x的父节点P进行左旋。(04) 左旋后，重新设置x的兄弟节点。（即：将X的父节点的右孩子设为新的兄弟节点W）</p>
<p><img src="https://images0.cnblogs.com/blog/381060/201405/222222498874304.png" alt="20140517000014"></p>
<p><strong>情况3.2、N的兄弟w是黑色的，且w的俩个孩子都是黑色的。</strong></p>
<p>处理策略是：(01) 将x的兄弟节点设为“红色”。(02) 设置“x的父节点”为“新的x节点”。</p>
<p><strong><img src="https://images0.cnblogs.com/blog/381060/201405/222222508091389.png" alt="20140517000015"></strong></p>
<p><strong>情况3.3、N的兄弟w是黑色的，w的左孩子是红色，w的右孩子是黑色。</strong></p>
<p> 针对这种情况是将节点W和其左子节点进行颜色交换，然后对W进行右旋转处理</p>
<p>处理策略是：</p>
<p>(01) 将x兄弟节点的左孩子X1设为“黑色”。(02) 将x兄弟节点W设为“红色”。(03) 对x的兄弟节点W进行右旋。(04) 右旋后，重新设置x的兄弟节点。（即：将X的父节点的右孩子设为新的兄弟节点）</p>
<p><img src="https://images0.cnblogs.com/blog/381060/201405/222222527772586.png" alt="20140517000016"></p>
<p><strong>情况3.4、N的兄弟w是黑色的，且w的右孩子时红色的。</strong></p>
<p> 交换W和父节点P的颜色，同时对P进行左旋转操作。这样就把左边缺失的黑色节点给补回来了。同时将W的右子节点X2置黑。这样左右都达到了平衡。</p>
<p><img src="https://images0.cnblogs.com/blog/381060/201405/222222535597415.png" alt="20140517000017"></p>
<p>处理策略是：</p>
<p>(01) 将x父节点P颜色赋值给 x的兄弟节点W。(02) 将x父节点P设为“黑色”。(03) 将x兄弟节点的右子节X2设为“黑色”。(04) 对x的父节点P进行左旋。(05) 设置“x”为“根节点”。</p>
<p>上述各种操作完成，最后都要把X设为黑色。</p>
<p> 下面列表给出每种情况以及解决方法：</p>
<p><img src="http://image.icool8.cn/blog/20201203/nWqdGkhi9K62.png?imageslim" alt="mark"></p>
<p>4.2 TreeMap delete()代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> 　　<span class="comment">/**</span></span><br><span class="line"><span class="comment"> 2      * Delete node p, and then rebalance the tree.</span></span><br><span class="line"><span class="comment"> 3      */</span></span><br><span class="line"> <span class="number">4</span>     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteEntry</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line"> <span class="number">5</span>         modCount++;</span><br><span class="line"> <span class="number">6</span>         size--;</span><br><span class="line"> <span class="number">7</span> </span><br><span class="line"> <span class="number">8</span>         <span class="comment">/*</span></span><br><span class="line"><span class="comment"> 9          * 被删除节点的左子树和右子树都不为空，那么就用 p节点的中序后继节点代替 p 节点</span></span><br><span class="line"><span class="comment">10          * successor(P)方法为寻找P的替代节点。规则是右分支最左边，或者 左分支最右边的节点</span></span><br><span class="line"><span class="comment">11          * </span></span><br><span class="line"><span class="comment">12          */</span></span><br><span class="line"><span class="number">13</span>         <span class="keyword">if</span> (p.left != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="number">14</span>             Entry&lt;K,V&gt; s = successor(p);</span><br><span class="line"><span class="number">15</span>             p.key = s.key;</span><br><span class="line"><span class="number">16</span>             p.value = s.value;</span><br><span class="line"><span class="number">17</span>             p = s;</span><br><span class="line"><span class="number">18</span>         &#125; <span class="comment">// p has 2 children</span></span><br><span class="line"><span class="number">19</span> </span><br><span class="line"><span class="number">20</span>         <span class="comment">//replacement为替代节点，如果P的左子树存在那么就用左子树替代，否则用右子树替代</span></span><br><span class="line"><span class="number">21</span>         Entry&lt;K,V&gt; replacement = (p.left != <span class="keyword">null</span> ? p.left : p.right);</span><br><span class="line"><span class="number">22</span> </span><br><span class="line"><span class="number">23</span>         <span class="comment">//如果替代节点不为空</span></span><br><span class="line"><span class="number">24</span>         <span class="keyword">if</span> (replacement != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="number">25</span>             <span class="comment">// Link replacement to parent</span></span><br><span class="line"><span class="number">26</span>             <span class="comment">/*</span></span><br><span class="line"><span class="comment">27              *replacement来替代P节点</span></span><br><span class="line"><span class="comment">28              */</span></span><br><span class="line"><span class="number">29</span>             <span class="comment">//若P没有父节点，则跟节点直接变成replacement</span></span><br><span class="line"><span class="number">30</span>             replacement.parent = p.parent;</span><br><span class="line"><span class="number">31</span>             <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">32</span>                 root = replacement;</span><br><span class="line"><span class="number">33</span>             <span class="comment">//如果P为左节点，则用replacement来替代为左节点</span></span><br><span class="line"><span class="number">34</span>             <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.left)</span><br><span class="line"><span class="number">35</span>                 p.parent.left  = replacement;</span><br><span class="line"><span class="number">36</span>             <span class="comment">//如果P为右节点，则用replacement来替代为右节点</span></span><br><span class="line"><span class="number">37</span>             <span class="keyword">else</span></span><br><span class="line"><span class="number">38</span>                 p.parent.right = replacement;</span><br><span class="line"><span class="number">39</span> </span><br><span class="line"><span class="number">40</span>             <span class="comment">// Null out links so they are OK to use by fixAfterDeletion.</span></span><br><span class="line"><span class="number">41</span>             p.left = p.right = p.parent = <span class="keyword">null</span>;</span><br><span class="line"><span class="number">42</span>                         </span><br><span class="line"><span class="number">43</span>             <span class="comment">/*</span></span><br><span class="line"><span class="comment">44              * 若P为红色直接删除，红黑树保持平衡</span></span><br><span class="line"><span class="comment">45              * 但是若P为黑色，则需要调整红黑树使其保持平衡</span></span><br><span class="line"><span class="comment">46              */</span></span><br><span class="line"><span class="number">47</span>             <span class="comment">// Fix replacement</span></span><br><span class="line"><span class="number">48</span>             <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line"><span class="number">49</span>                 fixAfterDeletion(replacement);</span><br><span class="line"><span class="number">50</span>         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>) &#123; <span class="comment">// return if we are the only node. p没有父节点，表示为P根节点，直接删除即可</span></span><br><span class="line"><span class="number">51</span>             root = <span class="keyword">null</span>;</span><br><span class="line"><span class="number">52</span>         &#125; <span class="keyword">else</span> &#123; <span class="comment">//  No children. Use self as phantom replacement and unlink.</span></span><br><span class="line"><span class="number">53</span>             <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line"><span class="number">54</span>                 fixAfterDeletion(p);</span><br><span class="line"><span class="number">55</span>                 </span><br><span class="line"><span class="number">56</span>             <span class="comment">//删除P节点</span></span><br><span class="line"><span class="number">57</span>             <span class="keyword">if</span> (p.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="number">58</span>                 <span class="keyword">if</span> (p == p.parent.left)</span><br><span class="line"><span class="number">59</span>                     p.parent.left = <span class="keyword">null</span>;</span><br><span class="line"><span class="number">60</span>                 <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.right)</span><br><span class="line"><span class="number">61</span>                     p.parent.right = <span class="keyword">null</span>;</span><br><span class="line"><span class="number">62</span>                 p.parent = <span class="keyword">null</span>;</span><br><span class="line"><span class="number">63</span>             &#125;</span><br><span class="line"><span class="number">64</span>         &#125;</span><br><span class="line"><span class="number">65</span>     &#125;</span><br></pre></td></tr></table></figure>
<p>寻找替代节点replacement，其实现方法为successor()，即寻找中序后继节点。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> 2   * Returns the successor of the specified Entry, or null if no such.</span></span><br><span class="line"><span class="comment"> 3   */</span></span><br><span class="line"> <span class="number">4</span> <span class="keyword">static</span> &lt;K,V&gt; TreeMap.<span class="function">Entry&lt;K,V&gt; <span class="title">successor</span><span class="params">(Entry&lt;K,V&gt; t)</span> </span>&#123;</span><br><span class="line"> <span class="number">5</span>         <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line"> <span class="number">6</span>             <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> <span class="number">7</span>         <span class="keyword">else</span> <span class="keyword">if</span> (t.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"> <span class="number">8</span>             Entry&lt;K,V&gt; p = t.right;</span><br><span class="line"> <span class="number">9</span>             <span class="keyword">while</span> (p.left != <span class="keyword">null</span>)</span><br><span class="line"><span class="number">10</span>                 p = p.left;</span><br><span class="line"><span class="number">11</span>             <span class="keyword">return</span> p;</span><br><span class="line"><span class="number">12</span>         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">13</span>             Entry&lt;K,V&gt; p = t.parent;</span><br><span class="line"><span class="number">14</span>             Entry&lt;K,V&gt; ch = t;</span><br><span class="line"><span class="number">15</span>             <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; ch == p.right) &#123;</span><br><span class="line"><span class="number">16</span>                 ch = p;</span><br><span class="line"><span class="number">17</span>                 p = p.parent;</span><br><span class="line"><span class="number">18</span>             &#125;</span><br><span class="line"><span class="number">19</span>             <span class="keyword">return</span> p;</span><br><span class="line"><span class="number">20</span>         &#125;</span><br><span class="line"><span class="number">21</span>     &#125;</span><br></pre></td></tr></table></figure>
<p>删除完节点后，就要根据情况来对红黑树进行复杂的调整：fixAfterDeletion()。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterDeletion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line"> <span class="number">2</span>         <span class="comment">// 删除节点需要一直迭代，知道 直到 x 不是根节点，且 x 的颜色是黑色</span></span><br><span class="line"> <span class="number">3</span>         <span class="keyword">while</span> (x != root &amp;&amp; colorOf(x) == BLACK) &#123;</span><br><span class="line"> <span class="number">4</span>             <span class="comment">//若X节点为左节点</span></span><br><span class="line"> <span class="number">5</span>             <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line"> <span class="number">6</span>                 <span class="comment">//获取其兄弟节点</span></span><br><span class="line"> <span class="number">7</span>                 Entry&lt;K,V&gt; sib = rightOf(parentOf(x));</span><br><span class="line"> <span class="number">8</span> </span><br><span class="line"> <span class="number">9</span>                 <span class="comment">//如果兄弟节点为红色----（情况3.1）</span></span><br><span class="line"><span class="number">10</span>                 <span class="keyword">if</span> (colorOf(sib) == RED) &#123;</span><br><span class="line"><span class="number">11</span>                     setColor(sib, BLACK);</span><br><span class="line"><span class="number">12</span>                     setColor(parentOf(x), RED);</span><br><span class="line"><span class="number">13</span>                     rotateLeft(parentOf(x));</span><br><span class="line"><span class="number">14</span>                     sib = rightOf(parentOf(x));</span><br><span class="line"><span class="number">15</span>                 &#125;</span><br><span class="line"><span class="number">16</span> </span><br><span class="line"><span class="number">17</span>                 <span class="comment">//兄弟节点为黑色</span></span><br><span class="line"><span class="number">18</span>                 <span class="comment">//兄弟节点的左右子节点都是黑色----（情况3.2）</span></span><br><span class="line"><span class="number">19</span>                 <span class="keyword">if</span> (colorOf(leftOf(sib))  == BLACK &amp;&amp;</span><br><span class="line"><span class="number">20</span>                     colorOf(rightOf(sib)) == BLACK) &#123;</span><br><span class="line"><span class="number">21</span>                     setColor(sib, RED);</span><br><span class="line"><span class="number">22</span>                     x = parentOf(x);</span><br><span class="line"><span class="number">23</span>                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">24</span>                     <span class="comment">//兄弟节点的只有右子节点为黑色，左子节点为红色----(情况3.3)</span></span><br><span class="line"><span class="number">25</span>                     <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK) &#123;</span><br><span class="line"><span class="number">26</span>                         setColor(leftOf(sib), BLACK);</span><br><span class="line"><span class="number">27</span>                         setColor(sib, RED);</span><br><span class="line"><span class="number">28</span>                         rotateRight(sib);</span><br><span class="line"><span class="number">29</span>                         sib = rightOf(parentOf(x));</span><br><span class="line"><span class="number">30</span>                     &#125;</span><br><span class="line"><span class="number">31</span>                     <span class="comment">//兄弟节点的右子节点是红色----(情况3.4)</span></span><br><span class="line"><span class="number">32</span>                     setColor(sib, colorOf(parentOf(x)));</span><br><span class="line"><span class="number">33</span>                     setColor(parentOf(x), BLACK);</span><br><span class="line"><span class="number">34</span>                     setColor(rightOf(sib), BLACK);</span><br><span class="line"><span class="number">35</span>                     rotateLeft(parentOf(x));</span><br><span class="line"><span class="number">36</span>                     x = root;</span><br><span class="line"><span class="number">37</span>                 &#125;</span><br><span class="line"><span class="number">38</span>             &#125; <span class="keyword">else</span> &#123; <span class="comment">// 对称的，X节点为右节点与其为做节点处理过程差不多，这里就不在累述了</span></span><br><span class="line"><span class="number">39</span>                 Entry&lt;K,V&gt; sib = leftOf(parentOf(x));</span><br><span class="line"><span class="number">40</span> </span><br><span class="line"><span class="number">41</span>                 <span class="keyword">if</span> (colorOf(sib) == RED) &#123;</span><br><span class="line"><span class="number">42</span>                     setColor(sib, BLACK);</span><br><span class="line"><span class="number">43</span>                     setColor(parentOf(x), RED);</span><br><span class="line"><span class="number">44</span>                     rotateRight(parentOf(x));</span><br><span class="line"><span class="number">45</span>                     sib = leftOf(parentOf(x));</span><br><span class="line"><span class="number">46</span>                 &#125;</span><br><span class="line"><span class="number">47</span> </span><br><span class="line"><span class="number">48</span>                 <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK &amp;&amp;</span><br><span class="line"><span class="number">49</span>                     colorOf(leftOf(sib)) == BLACK) &#123;</span><br><span class="line"><span class="number">50</span>                     setColor(sib, RED);</span><br><span class="line"><span class="number">51</span>                     x = parentOf(x);</span><br><span class="line"><span class="number">52</span>                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">53</span>                     <span class="keyword">if</span> (colorOf(leftOf(sib)) == BLACK) &#123;</span><br><span class="line"><span class="number">54</span>                         setColor(rightOf(sib), BLACK);</span><br><span class="line"><span class="number">55</span>                         setColor(sib, RED);</span><br><span class="line"><span class="number">56</span>                         rotateLeft(sib);</span><br><span class="line"><span class="number">57</span>                         sib = leftOf(parentOf(x));</span><br><span class="line"><span class="number">58</span>                     &#125;</span><br><span class="line"><span class="number">59</span>                     setColor(sib, colorOf(parentOf(x)));</span><br><span class="line"><span class="number">60</span>                     setColor(parentOf(x), BLACK);</span><br><span class="line"><span class="number">61</span>                     setColor(leftOf(sib), BLACK);</span><br><span class="line"><span class="number">62</span>                     rotateRight(parentOf(x));</span><br><span class="line"><span class="number">63</span>                     x = root;</span><br><span class="line"><span class="number">64</span>                 &#125;</span><br><span class="line"><span class="number">65</span>             &#125;</span><br><span class="line"><span class="number">66</span>         &#125;</span><br><span class="line"><span class="number">67</span> </span><br><span class="line"><span class="number">68</span>         setColor(x, BLACK);</span><br><span class="line"><span class="number">69</span>     &#125;</span><br></pre></td></tr></table></figure>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Jia Xufeng</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://icool8.cn/2019/03/27/Blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%B9%E6%8D%AE%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E7%AE%97%E6%B3%95%E6%9D%A5%E5%88%86%E6%9E%90TreeMap%E7%9A%84%E5%AE%9E%E7%8E%B0/">https://icool8.cn/2019/03/27/Blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%B9%E6%8D%AE%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E7%AE%97%E6%B3%95%E6%9D%A5%E5%88%86%E6%9E%90TreeMap%E7%9A%84%E5%AE%9E%E7%8E%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/TreeMap/">TreeMap</a><a class="post-meta__tags" href="/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/">红黑树</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/06/12/Blog/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%90%8C%E6%AD%A5%E9%94%81%E4%B9%8BAQS%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><i class="fa fa-chevron-left">  </i><span>同步锁之AQS源码分析</span></a></div><div class="next-post pull-right"><a href="/2019/03/07/Blog/java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B9%8B%E9%99%90%E6%B5%81/"><span>高并发之限流</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By Jia Xufeng</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>