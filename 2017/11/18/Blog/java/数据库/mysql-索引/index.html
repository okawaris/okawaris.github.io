<!DOCTYPE html><html lang="zh-tw"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="mysql-索引"><meta name="keywords" content="mysql,索引"><meta name="author" content="Jia Xufeng"><meta name="copyright" content="Jia Xufeng"><title>mysql-索引 | 暗夜精灵のBlog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 5.3.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">1.</span> <span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%A3%80%E7%B4%A2%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">索引检索为什么快？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E4%B8%AD%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">MySQL中索引类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%AE%A1%E7%90%86%E8%AF%AD%E6%B3%95"><span class="toc-number">1.3.</span> <span class="toc-text">索引管理语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%B4%A2%E5%BC%95"><span class="toc-number">1.3.1.</span> <span class="toc-text">查看索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">1.3.2.</span> <span class="toc-text">创建索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%A1%A8%E4%B9%8B%E5%90%8E%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">创建表之后建立索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%A1%A8%E6%97%B6%E6%8C%87%E5%AE%9A%E7%B4%A2%E5%BC%95"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">创建表时指定索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95"><span class="toc-number">1.3.3.</span> <span class="toc-text">删除索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92explain"><span class="toc-number">1.4.</span> <span class="toc-text">执行计划explain</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">1.5.</span> <span class="toc-text">索引使用场景（重点）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#where"><span class="toc-number">1.5.1.</span> <span class="toc-text">where</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#order-by"><span class="toc-number">1.5.2.</span> <span class="toc-text">order by</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#join"><span class="toc-number">1.5.3.</span> <span class="toc-text">join</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96%EF%BC%9F"><span class="toc-number">1.5.4.</span> <span class="toc-text">索引覆盖？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%82%EF%BC%88%E8%A6%81%E7%82%B9%EF%BC%89"><span class="toc-number">1.6.</span> <span class="toc-text">语法细节（要点）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E8%A6%81%E7%8B%AC%E7%AB%8B%E5%87%BA%E7%8E%B0"><span class="toc-number">1.6.1.</span> <span class="toc-text">字段要独立出现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#like%E6%9F%A5%E8%AF%A2%EF%BC%8C%E4%B8%8D%E8%83%BD%E4%BB%A5%E9%80%9A%E9%85%8D%E7%AC%A6%E5%BC%80%E5%A4%B4"><span class="toc-number">1.6.2.</span> <span class="toc-text">like查询，不能以通配符开头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95%E5%8F%AA%E5%AF%B9%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AD%97%E6%AE%B5%E6%9C%89%E6%95%88%EF%BC%88%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99%EF%BC%89"><span class="toc-number">1.6.3.</span> <span class="toc-text">复合索引只对第一个字段有效（最左匹配原则）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#or%EF%BC%8C%E4%B8%A4%E8%BE%B9%E6%9D%A1%E4%BB%B6%E9%83%BD%E6%9C%89%E7%B4%A2%E5%BC%95%E5%8F%AF%E7%94%A8"><span class="toc-number">1.6.4.</span> <span class="toc-text">or，两边条件都有索引可用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E5%80%BC%EF%BC%8C%E4%B8%8D%E5%AE%B9%E6%98%93%E4%BD%BF%E7%94%A8%E5%88%B0%E7%B4%A2%E5%BC%95"><span class="toc-number">1.6.5.</span> <span class="toc-text">状态值，不容易使用到索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">1.7.</span> <span class="toc-text">如何创建索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95"><span class="toc-number">1.8.</span> <span class="toc-text">前缀索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.9.</span> <span class="toc-text">索引的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#B-Tree"><span class="toc-number">1.9.1.</span> <span class="toc-text">B-Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-Tree-1"><span class="toc-number">1.9.2.</span> <span class="toc-text">B+Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95"><span class="toc-number">1.9.3.</span> <span class="toc-text">哈希索引</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="http://image.icool8.cn/bolg/20210107112538.png"></div><div class="author-info__name text-center">Jia Xufeng</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">89</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">85</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">31</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友情链接</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://wiliam.me/">wiliam</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://molunerfinn.com/hexo-theme-melody-doc/zh-Hans/">melody</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(http://image.icool8.cn/bolg/20210107113114.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">暗夜精灵のBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">mysql-索引</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-11-18</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/">mysql</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><blockquote>
<p>关键字与数据的映射关系称为索引（==包含关键字和对应的记录在磁盘中的地址==）。关键字是从数据当中提取的用于标识、检索数据的特定内容。</p>
</blockquote>
<h2 id="索引检索为什么快？"><a href="#索引检索为什么快？" class="headerlink" title="索引检索为什么快？"></a>索引检索为什么快？</h2><ul>
<li>关键字相对于数据本身，==数据量小==</li>
<li>关键字是==有序==的，二分查找可快速确定位置</li>
</ul>
<p>图书馆为每本书都加了索引号（类别-楼层-书架）、字典为词语解释按字母顺序编写目录等都用到了索引。</p>
<h2 id="MySQL中索引类型"><a href="#MySQL中索引类型" class="headerlink" title="MySQL中索引类型"></a>MySQL中索引类型</h2><blockquote>
<p><strong>普通索引</strong>（<code>key</code>），<strong>唯一索引</strong>（<code>unique key</code>），<strong>主键索引</strong>（<code>primary key</code>），<strong>全文索引</strong>（<code>fulltext key</code>）</p>
</blockquote>
<p>三种索引的索引方式是一样的，只不过对索引的关键字有不同的限制：</p>
<ul>
<li>普通索引：对关键字没有限制</li>
<li>唯一索引：要求记录提供的关键字不能重复</li>
<li>主键索引：要求关键字唯一且不为null</li>
</ul>
<a id="more"></a>

<h2 id="索引管理语法"><a href="#索引管理语法" class="headerlink" title="索引管理语法"></a>索引管理语法</h2><h3 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h3><p><code>show create table 表名</code>：</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/8a217f9960d10e28c76bc80a1fd80c0afd8b60ddeebf8002d7109d806ea20e82/687474703a2f2f7a616e77656e626c6f672e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d32362f35313435373234362e6a7067"><img src="https://camo.githubusercontent.com/8a217f9960d10e28c76bc80a1fd80c0afd8b60ddeebf8002d7109d806ea20e82/687474703a2f2f7a616e77656e626c6f672e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d32362f35313435373234362e6a7067" alt="img"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">desc 表名</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/677f3869319955a48244c0c00b04f8630f3c28086108cbad311a72a9dd0aad90/687474703a2f2f7a616e77656e626c6f672e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d32362f39373030353333342e6a7067"><img src="https://camo.githubusercontent.com/677f3869319955a48244c0c00b04f8630f3c28086108cbad311a72a9dd0aad90/687474703a2f2f7a616e77656e626c6f672e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d32362f39373030353333342e6a7067" alt="img"></a></p>
<h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><h4 id="创建表之后建立索引"><a href="#创建表之后建立索引" class="headerlink" title="创建表之后建立索引"></a>创建表之后建立索引</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">create TABLE user_index(</span><br><span class="line">	id int auto_increment primary key,</span><br><span class="line">	first_name varchar(16),</span><br><span class="line">	last_name VARCHAR(16),</span><br><span class="line">	id_card VARCHAR(18),</span><br><span class="line">	information text</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 更改表结构</span><br><span class="line">alter table user_index</span><br><span class="line">-- 创建一个first_name和last_name的复合索引，并命名为name</span><br><span class="line">add key name (first_name,last_name),</span><br><span class="line">-- 创建一个id_card的唯一索引，默认以字段名作为索引名</span><br><span class="line">add UNIQUE KEY (id_card),</span><br><span class="line">-- 鸡肋，全文索引不支持中文</span><br><span class="line">add FULLTEXT KEY (information);</span><br></pre></td></tr></table></figure>
<p><code>show create table user_index</code>：</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/06ee23e1f64116b659e2c6fa6eaffdcdfa75c4adf39918fd85641e1a4bb196e6/687474703a2f2f7a616e77656e626c6f672e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d32362f38373633373534342e6a7067"><img src="https://camo.githubusercontent.com/06ee23e1f64116b659e2c6fa6eaffdcdfa75c4adf39918fd85641e1a4bb196e6/687474703a2f2f7a616e77656e626c6f672e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d32362f38373633373534342e6a7067" alt="img"></a></p>
<h4 id="创建表时指定索引"><a href="#创建表时指定索引" class="headerlink" title="创建表时指定索引"></a>创建表时指定索引</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE user_index2 (</span><br><span class="line">	id INT auto_increment PRIMARY KEY,</span><br><span class="line">	first_name VARCHAR (16),</span><br><span class="line">	last_name VARCHAR (16),</span><br><span class="line">	id_card VARCHAR (18),</span><br><span class="line">	information text,</span><br><span class="line">	KEY name (first_name, last_name),</span><br><span class="line">	FULLTEXT KEY (information),</span><br><span class="line">	UNIQUE KEY (id_card)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><p>根据索引名删除普通索引、唯一索引、全文索引：<code>alter table 表名 drop KEY 索引名</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alter table user_index drop KEY name;</span><br><span class="line">alter table user_index drop KEY id_card;</span><br><span class="line">alter table user_index drop KEY information;</span><br></pre></td></tr></table></figure>
<p>删除主键索引：<code>alter table 表名 drop primary key</code>（因为主键只有一个）。这里值得注意的是，如果主键自增长，那么不能直接执行此操作（自增长依赖于主键索引）：</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/30902d5b11fa5febd1610629cd612afd2c769e02bf0ce45140897f014ab6697d/687474703a2f2f7a616e77656e626c6f672e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d32362f32323339323035342e6a7067"><img src="https://camo.githubusercontent.com/30902d5b11fa5febd1610629cd612afd2c769e02bf0ce45140897f014ab6697d/687474703a2f2f7a616e77656e626c6f672e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d32362f32323339323035342e6a7067" alt="img"></a></p>
<p>需要取消自增长再行删除：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alter table user_index</span><br><span class="line">-- 重新定义字段</span><br><span class="line">MODIFY id int,</span><br><span class="line">drop PRIMARY KEY</span><br></pre></td></tr></table></figure>
<p>但通常不会删除主键，因为设计主键一定与业务逻辑无关。</p>
<h2 id="执行计划explain"><a href="#执行计划explain" class="headerlink" title="执行计划explain"></a>执行计划explain</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE innodb1 (</span><br><span class="line">	id INT auto_increment PRIMARY KEY,</span><br><span class="line">	first_name VARCHAR (16),</span><br><span class="line">	last_name VARCHAR (16),</span><br><span class="line">	id_card VARCHAR (18),</span><br><span class="line">	information text,</span><br><span class="line">	KEY name (first_name, last_name),</span><br><span class="line">	FULLTEXT KEY (information),</span><br><span class="line">	UNIQUE KEY (id_card)</span><br><span class="line">);</span><br><span class="line">insert into innodb1 (first_name,last_name,id_card,information) values (&#39;张&#39;,&#39;三&#39;,&#39;1001&#39;,&#39;华山派&#39;);</span><br></pre></td></tr></table></figure>
<p>我们可以通过<code>explain selelct</code>来分析SQL语句执行前的执行计划：</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/28bf20e4c96082e0469802cf084a36b7a55851afd1060b0eb6854f1218fc1c2f/687474703a2f2f7a616e77656e626c6f672e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d32362f36363136373133372e6a7067"><img src="https://camo.githubusercontent.com/28bf20e4c96082e0469802cf084a36b7a55851afd1060b0eb6854f1218fc1c2f/687474703a2f2f7a616e77656e626c6f672e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d32362f36363136373133372e6a7067" alt="img"></a></p>
<p>由上图可看出此SQL语句是按照主键索引来检索的。</p>
<p>执行计划是：当执行SQL语句时，首先会分析、优化，形成执行计划，在按照执行计划执行。</p>
<h2 id="索引使用场景（重点）"><a href="#索引使用场景（重点）" class="headerlink" title="索引使用场景（重点）"></a>索引使用场景（重点）</h2><h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/aad0e046a89487f2f485614c8c8735d5086f271528bf1321bf34f52cd442152f/687474703a2f2f7a616e77656e626c6f672e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d32362f343439323037392e6a7067"><img src="https://camo.githubusercontent.com/aad0e046a89487f2f485614c8c8735d5086f271528bf1321bf34f52cd442152f/687474703a2f2f7a616e77656e626c6f672e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d32362f343439323037392e6a7067" alt="img"></a></p>
<p>上图中，根据<code>id</code>查询记录，因为<code>id</code>字段仅建立了主键索引，因此此SQL执行可选的索引只有主键索引，如果有多个，最终会选一个较优的作为检索的依据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 增加一个没有建立索引的字段</span><br><span class="line">alter table innodb1 add sex char(1);</span><br><span class="line">-- 按sex检索时可选的索引为null</span><br><span class="line">EXPLAIN SELECT * from innodb1 where sex&#x3D;&#39;男&#39;;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/bed42775b7a4f66547a7a4d6f2da0c30b4a1875f4f85a82321acf849ec5c8bed/687474703a2f2f7a616e77656e626c6f672e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d32362f33333931363832352e6a7067"><img src="https://camo.githubusercontent.com/bed42775b7a4f66547a7a4d6f2da0c30b4a1875f4f85a82321acf849ec5c8bed/687474703a2f2f7a616e77656e626c6f672e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d32362f33333931363832352e6a7067" alt="img"></a></p>
<blockquote>
<p>可以尝试在一个字段未建立索引时，根据该字段查询的效率，然后对该字段建立索引（<code>alter table 表名 add index(字段名)</code>），同样的SQL执行的效率，你会发现查询效率会有明显的提升（数据量越大越明显）。</p>
</blockquote>
<h3 id="order-by"><a href="#order-by" class="headerlink" title="order by"></a>order by</h3><p>当我们使用<code>order by</code>将查询结果按照某个字段排序时，如果该字段没有建立索引，那么执行计划会将查询出的所有数据使用外部排序（将数据从硬盘分批读取到内存使用内部排序，最后合并排序结果），这个操作是很影响性能的，因为需要将查询涉及到的所有数据从磁盘中读到内存（如果单条数据过大或者数据量过多都会降低效率），更无论读到内存之后的排序了。</p>
<p>但是如果我们对该字段建立索引<code>alter table 表名 add index(字段名)</code>，那么由于索引本身是有序的，因此直接按照索引的顺序和映射关系逐条取出数据即可。而且如果分页的，那么只用<strong>取出索引表某个范围内的索引对应的数据</strong>，而不用像上述那<strong>取出所有数据</strong>进行排序再返回某个范围内的数据。（从磁盘取数据是最影响性能的）</p>
<h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><blockquote>
<p>对<code>join</code>语句匹配关系（<code>on</code>）涉及的字段建立索引能够提高效率</p>
</blockquote>
<h3 id="索引覆盖？"><a href="#索引覆盖？" class="headerlink" title="索引覆盖？"></a>索引覆盖？</h3><p>如果要查询的字段都建立过索引，那么引擎会直接在索引表中查询而不会访问原始数据（否则只要有一个字段没有建立索引就会做全表扫描），这叫索引覆盖。因此我们需要尽可能的在<code>select</code>后==只写必要的查询字段==，以增加索引覆盖的几率。</p>
<p>这里值得注意的是不要想着为每个字段建立索引，因为优先使用索引的优势就在于其体积小。</p>
<h2 id="语法细节（要点）"><a href="#语法细节（要点）" class="headerlink" title="语法细节（要点）"></a>语法细节（要点）</h2><blockquote>
<p>在满足索引使用的场景下（<code>where/order by/join on</code>或索引覆盖），索引也不一定被使用</p>
</blockquote>
<h3 id="字段要独立出现"><a href="#字段要独立出现" class="headerlink" title="字段要独立出现"></a>字段要独立出现</h3><p>比如下面两条SQL语句在语义上相同，但是第一条会使用主键索引而第二条不会。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from user where id &#x3D; 20-1;</span><br><span class="line">select * from user where id+1 &#x3D; 20;</span><br></pre></td></tr></table></figure>
<h3 id="like查询，不能以通配符开头"><a href="#like查询，不能以通配符开头" class="headerlink" title="like查询，不能以通配符开头"></a><code>like</code>查询，不能以通配符开头</h3><p>比如搜索标题包含<code>mysql</code>的文章：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from article where title like &#39;%mysql%&#39;;</span><br></pre></td></tr></table></figure>
<p>这种SQL的执行计划用不了索引（<code>like</code>语句匹配表达式以通配符开头），因此只能做全表扫描，效率极低，在实际工程中几乎不被采用。而一般会使用第三方提供的支持中文的全文索引来做。</p>
<p>但是 <strong>关键字查询</strong> 热搜提醒功能还是可以做的，比如键入<code>mysql</code>之后提醒<code>mysql 教程</code>、<code>mysql 下载</code>、<code>mysql 安装步骤</code>等。用到的语句是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from article where title like &#39;mysql%&#39;;</span><br></pre></td></tr></table></figure>
<p>这种<code>like</code>是可以利用索引的（当然前提是<code>title</code>字段建立过索引）。</p>
<h3 id="复合索引只对第一个字段有效（最左匹配原则）"><a href="#复合索引只对第一个字段有效（最左匹配原则）" class="headerlink" title="复合索引只对第一个字段有效（最左匹配原则）"></a>复合索引只对第一个字段有效（最左匹配原则）</h3><p>建立复合索引：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table person add index(first_name,last_name);</span><br></pre></td></tr></table></figure>
<p>其原理就是将索引先按照从<code>first_name</code>中提取的关键字排序，如果无法确定先后再按照从<code>last_name</code>提取的关键字排序，也就是说该索引表只是按照记录的<code>first_name</code>字段值有序。</p>
<p>因此<code>select * from person where first_name = ?</code>是可以利用索引的，而<code>select * from person where last_name = ?</code>无法利用索引。</p>
<blockquote>
<p>那么该复合索引的应用场景是什么？==组合查询==</p>
</blockquote>
<p>比如对于<code>select * person from first_name = ? and last_name = ?</code>，复合索引就比对<code>first_name</code>和<code>last_name</code>单独建立索引要高效些。很好理解，复合索引首先二分查找与<code>first_name = ?</code>匹配的记录，再在这些记录中二分查找与<code>last_name</code>匹配的记录，只涉及到一张索引表。而分别单独建立索引则是在<code>first_name</code>索引表中二分找出与<code>first_name = ?</code>匹配的记录，再在<code>last_name</code>索引表中二分找出与<code>last_name = ?</code>的记录，两者取交集。</p>
<h3 id="or，两边条件都有索引可用"><a href="#or，两边条件都有索引可用" class="headerlink" title="or，两边条件都有索引可用"></a>or，两边条件都有索引可用</h3><blockquote>
<p>一但有一边无索引可用就会导致整个SQL语句的全表扫描</p>
</blockquote>
<h3 id="状态值，不容易使用到索引"><a href="#状态值，不容易使用到索引" class="headerlink" title="状态值，不容易使用到索引"></a>状态值，不容易使用到索引</h3><p>如性别、支付状态等状态值字段往往只有极少的几种取值可能，这种字段即使建立索引，也往往利用不上。这是因为，一个状态值可能匹配大量的记录，这种情况MySQL会认为利用索引比全表扫描的效率低，从而弃用索引。索引是随机访问磁盘，而全表扫描是顺序访问磁盘，这就好比有一栋20层楼的写字楼，楼底下的索引牌上写着某个公司对应不相邻的几层楼，你去公司找人，与其按照索引牌的提示去其中一层楼没找到再下来看索引牌再上楼，不如从1楼挨个往上找到顶楼。</p>
<h2 id="如何创建索引"><a href="#如何创建索引" class="headerlink" title="如何创建索引"></a>如何创建索引</h2><ul>
<li>建立基础索引：在<code>where、order by、join</code>字段上建立索引。</li>
<li>优化，组合索引：基于业务逻辑<ul>
<li>如果条件经常性出现在一起，那么可以考虑将多字段索引升级为==复合索引==</li>
<li>如果通过增加个别字段的索引，就可以出现==索引覆盖==，那么可以考虑为该字段建立索引</li>
<li>查询时，不常用到的索引，应该删除掉</li>
</ul>
</li>
</ul>
<h2 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h2><p>语法：<code>index(field(10))</code>，使用字段值的前10个字符建立索引，默认是使用字段的全部内容建立索引。</p>
<p>前提：前缀的标识度高。比如密码就适合建立前缀索引，因为密码几乎各不相同。</p>
<p>==实操的难度==：在于前缀截取的长度。</p>
<p>我们可以利用<code>select count(*)/count(distinct left(password,prefixLen));</code>，通过从调整<code>prefixLen</code>的值（从1自增）查看不同前缀长度的一个平均匹配度，接近1时就可以了（表示一个密码的前<code>prefixLen</code>个字符几乎能确定唯一一条记录）</p>
<h2 id="索引的存储结构"><a href="#索引的存储结构" class="headerlink" title="索引的存储结构"></a>索引的存储结构</h2><h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h3><p>b-tree（多路平衡查找树，又名BTree）是一种广泛应用于==磁盘上实现索引功能==的一种数据结构，也是大多数数据库索引表的实现。</p>
<p>以<code>add index(first_name,last_name)</code>为例：</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/39f47c45d834a805697f0ba1ff3f49bc71c5df75cd25428c088cc6775612208f/687474703a2f2f7a616e77656e626c6f672e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d32362f31343732383935352e6a7067"><img src="https://camo.githubusercontent.com/39f47c45d834a805697f0ba1ff3f49bc71c5df75cd25428c088cc6775612208f/687474703a2f2f7a616e77656e626c6f672e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d32362f31343732383935352e6a7067" alt="img"></a></p>
<p>B-Tree的一个node可以存储多个关键字，node的大小取决于计算机的文件系统，因此我们可以通过减小索引字段的长度使结点存储更多的关键字。如果node中的关键字已满，那么可以通过每个关键字之间的子节点指针来拓展索引表，但是不能破坏结构的有序性，比如按照<code>first_name</code>第一有序、<code>last_name</code>第二有序的规则，新添加的<code>韩香</code>就可以插到<code>韩康</code>之后。<code>白起 &lt; 韩飞 &lt; 韩康 &lt; 李世民 &lt; 李寻欢 &lt; 王语嫣 &lt; 杨不悔&lt; 赵奢 </code>。这与二叉搜索树的思想是一样的，只不过二叉搜索树的查找效率是<code>log(2,N)</code>（以2为底N的对数），而BTree的查找效率是<code>log(x,N)</code>（其中x为node的关键字数量，可以达到1000以上）。</p>
<p>从<code>log(1000+,N)</code>可以看出，少量的磁盘读取即可做到大量数据的遍历，这也是btree的设计目的。</p>
<h3 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h3><p>B+Tree和B-Tree(BTree/B树)的区别是：</p>
<ol>
<li>B+树非叶子节点不存放数据，只存放keys。</li>
<li>B+树的叶子节点之间存在指针相连，而且是单链表</li>
</ol>
<p>在mysql中，仅仅只有<code>Innodb</code>的<strong>主键索引为聚簇结构</strong>，在聚簇索引中，叶子节点存放的是表中的<strong>行数据</strong>,所以，主键索引查询速度最快，因为在主键索引中就已经包含了索要查找的所有数据。</p>
<p>但是在MyISAM主键索引或其他索引里，叶子节点存放的是主键key，所以在查询时，其实是先查询辅助索引，然后再查主键索引。</p>
<p><img src="http://image.icool8.cn/blog/20201207/Y6CK7zhA7L2X.png?imageslim" alt="mark"></p>
<p>关于B+tree的更深入的理解请参考<br>[数据库索引为什么使用B+树]: 数据库索引为什么使用B+树</p>
<h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>在索引被载入内存时，使用哈希结构来存储。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Jia Xufeng</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://icool8.cn/2017/11/18/Blog/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql-%E7%B4%A2%E5%BC%95/">https://icool8.cn/2017/11/18/Blog/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql-%E7%B4%A2%E5%BC%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/mysql/">mysql</a><a class="post-meta__tags" href="/tags/%E7%B4%A2%E5%BC%95/">索引</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="http://image.icool8.cn/bolg/20210107114718.png"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="http://image.icool8.cn/bolg/20210107114632.png"><div class="post-qr-code__desc">微信打赏</div></div></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2017/11/23/Blog/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql-%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87-%E5%88%86%E5%8C%BA/"><i class="fa fa-chevron-left">  </i><span>mysql-性能提升-分区</span></a></div><div class="next-post pull-right"><a href="/2017/11/17/Blog/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql-MyISAM%E5%92%8CInnodb%E7%9A%84%E5%8C%BA%E5%88%AB/"><span>mysql-MyISAM和Innodb的区别</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(http://image.icool8.cn/bolg/20210107113114.png)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By Jia Xufeng</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>