<!DOCTYPE html><html lang="zh-tw"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="常见问题之 Netty（上）"><meta name="keywords" content="NIO"><meta name="author" content="Jia Xufeng"><meta name="copyright" content="Jia Xufeng"><title>常见问题之 Netty（上） | 暗夜精灵のBlog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 5.3.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#BIO-NIO%E5%92%8CAIO%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.</span> <span class="toc-text">BIO,NIO和AIO的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Netty-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">Netty 是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E5%95%A5%E4%B8%8D%E7%9B%B4%E6%8E%A5%E7%94%A8NIO%E5%91%A2"><span class="toc-number">3.</span> <span class="toc-text">为啥不直接用NIO呢?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-Netty%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">为什么要用 Netty？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%82%A3%E4%BA%9B%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E7%94%A8%E5%88%B0%E4%BA%86Netty"><span class="toc-number">5.</span> <span class="toc-text">那些开源项目用到了Netty?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BNetty%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%EF%BC%9F"><span class="toc-number">6.</span> <span class="toc-text">介绍一下Netty的核心组件？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Bytebuf%EF%BC%88%E5%AD%97%E8%8A%82%E5%AE%B9%E5%99%A8%EF%BC%89"><span class="toc-number">6.1.</span> <span class="toc-text">Bytebuf（字节容器）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bootstrap-%E5%92%8C-ServerBootstrap%EF%BC%88%E5%90%AF%E5%8A%A8%E5%BC%95%E5%AF%BC%E7%B1%BB%EF%BC%89"><span class="toc-number">6.2.</span> <span class="toc-text">Bootstrap 和 ServerBootstrap（启动引导类）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Channel%EF%BC%88%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%89"><span class="toc-number">6.3.</span> <span class="toc-text">Channel（网络操作抽象类）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EventLoop%EF%BC%88%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%89"><span class="toc-number">6.4.</span> <span class="toc-text">EventLoop（事件循环）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#EventLoop-%E4%BB%8B%E7%BB%8D"><span class="toc-number">6.4.1.</span> <span class="toc-text">EventLoop 介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Channel-%E5%92%8C-EventLoop-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">6.4.2.</span> <span class="toc-text">Channel 和 EventLoop 的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EventloopGroup-%E5%92%8C-EventLoop-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">6.4.3.</span> <span class="toc-text">EventloopGroup 和 EventLoop 的关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ChannelHandler%EF%BC%88%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E5%99%A8%EF%BC%89-%E5%92%8C-ChannelPipeline%EF%BC%88ChannelHandler-%E5%AF%B9%E8%B1%A1%E9%93%BE%E8%A1%A8%EF%BC%89"><span class="toc-number">6.5.</span> <span class="toc-text">ChannelHandler（消息处理器） 和 ChannelPipeline（ChannelHandler 对象链表）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ChannelFuture%EF%BC%88%E6%93%8D%E4%BD%9C%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C%EF%BC%89"><span class="toc-number">6.6.</span> <span class="toc-text">ChannelFuture（操作执行结果）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bootstrap-%E5%92%8C-ServerBootstrap-%E4%BA%86%E8%A7%A3%E4%B9%88%EF%BC%9F"><span class="toc-number">7.</span> <span class="toc-text">Bootstrap 和 ServerBootstrap 了解么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NioEventLoopGroup-%E9%BB%98%E8%AE%A4%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%BC%9A%E8%B5%B7%E5%A4%9A%E5%B0%91%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-number">8.</span> <span class="toc-text">NioEventLoopGroup 默认的构造函数会起多少线程？</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="http://image.icool8.cn/bolg/20210107112538.png"></div><div class="author-info__name text-center">Jia Xufeng</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">89</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">85</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">31</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友情链接</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://wiliam.me/">wiliam</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://molunerfinn.com/hexo-theme-melody-doc/zh-Hans/">melody</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(http://image.icool8.cn/bolg/20210107113114.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">暗夜精灵のBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">常见问题之 Netty（上）</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-10-01</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Netty/">Netty</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="BIO-NIO和AIO的区别"><a href="#BIO-NIO和AIO的区别" class="headerlink" title="BIO,NIO和AIO的区别"></a>BIO,NIO和AIO的区别</h2><p><img src="http://image.icool8.cn/blog/20201206/Cr2IlvgQavAA.png?imageslim" alt="mark"></p>
<ul>
<li><strong>BIO (Blocking I/O):</strong> 同步阻塞 I/O 模式，数据的读取写入必须阻塞在一个线程内等待其完成。在客户端连接数量不高的情况下，是没问题的。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</li>
<li><strong>NIO (Non-blocking/New I/O):</strong> NIO 是一种同步非阻塞的 I/O 模型，于 Java 1.4 中引入，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它支持面向缓冲的，基于通道的 I/O 操作方法。 NIO 提供了与传统 BIO 模型中的 <code>Socket</code> 和 <code>ServerSocket</code> 相对应的 <code>SocketChannel</code> 和 <code>ServerSocketChannel</code> 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发</li>
<li><strong>AIO (Asynchronous I/O):</strong> AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的 IO 模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步 IO 的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO 操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。</li>
</ul>
<a id="more"></a>

<p><strong>同步和异步说的是IO操作，阻塞非阻塞说的是线程的状态 。</strong></p>
<h2 id="Netty-是什么？"><a href="#Netty-是什么？" class="headerlink" title="Netty 是什么？"></a>Netty 是什么？</h2><p>👨‍💻<strong>面试官</strong> ：那你再来介绍一下自己对 Netty 的认识吧！小伙子。</p>
<p>🙋 <strong>我</strong> ：好的！那我就简单用 3 点来概括一下 Netty 吧！</p>
<ol>
<li>Netty 是一个 <strong>基于 NIO</strong> 的 client-server(客户端服务器)框架，使用它可以快速简单地开发网络应用程序。</li>
<li>它极大地简化并优化了 TCP 和 UDP 套接字服务器等网络编程,并且性能以及安全性等很多方面甚至都要更好。</li>
<li><strong>支持多种协议</strong> 如 FTP，SMTP，HTTP 以及各种二进制和基于文本的传统协议。</li>
</ol>
<p>用官方的总结就是：<strong>Netty 成功地找到了一种在不妥协可维护性和性能的情况下实现易于开发，性能，稳定性和灵活性的方法。</strong></p>
<p><em>网络编程我愿意称中 Netty 为王 。</em></p>
<h2 id="为啥不直接用NIO呢"><a href="#为啥不直接用NIO呢" class="headerlink" title="为啥不直接用NIO呢?"></a>为啥不直接用NIO呢?</h2><p>👨‍💻<strong>面试官</strong> ：你上面也说了Netty基于NIO，那为啥不直接用NIO呢?。</p>
<p>不用NIO主要是因为NIO的编程模型复杂而且存在一些BUG，并且对编程功底要求比较高。下图就是一个典型的使用 NIO 进行编程的案例：</p>
<p><img src="http://image.icool8.cn/blog/20201206/TD5i94TxIbEP.png?imageslim" alt="mark"></p>
<p>而且，NIO在面对断连重连、包丢失、粘包等问题时处理过程非常复杂。Netty的出现正是为了解决这些问题，更多关于Netty的特点可以看下面的内容。</p>
<h2 id="为什么要用-Netty？"><a href="#为什么要用-Netty？" class="headerlink" title="为什么要用 Netty？"></a>为什么要用 Netty？</h2><p>👨‍💻<strong>面试官</strong> ：为什么要用 Netty 呢？能不能说一下自己的看法。</p>
<p>🙋 <strong>我</strong> ：因为 Netty 具有下面这些优点，并且相比于直接使用 JDK 自带的 NIO 相关的 API 来说更加易用。</p>
<ul>
<li>统一的 API，支持多种传输类型，阻塞和非阻塞的。</li>
<li>简单而强大的线程模型。</li>
<li>自带编解码器解决 TCP 粘包/拆包问题。</li>
<li>自带各种协议栈。</li>
<li>真正的无连接数据包套接字支持。</li>
<li>比直接使用 Java 核心 API 有更高的吞吐量、更低的延迟、更低的资源消耗和更少的内存复制。</li>
<li>安全性不错，有完整的 SSL/TLS 以及 StartTLS 支持。</li>
<li>社区活跃</li>
<li>成熟稳定，经历了大型项目的使用和考验，而且很多开源项目都使用到了 Netty， 比如我们经常接触的 Dubbo、RocketMQ 等等。</li>
<li>……</li>
</ul>
<h2 id="那些开源项目用到了Netty"><a href="#那些开源项目用到了Netty" class="headerlink" title="那些开源项目用到了Netty?"></a>那些开源项目用到了Netty?</h2><p>我们平常经常接触的 Dubbo、RocketMQ、Elasticsearch、gRPC 等等都用到了 Netty。</p>
<p>可以说大量的开源项目都用到了 Netty，所以掌握 Netty 有助于你更好的使用这些开源项目并且让你有能力对其进行二次开发。</p>
<p>实际上还有很多很多优秀的项目用到了 Netty,Netty 官方也做了统计，统计结果在这里：<a target="_blank" rel="noopener" href="https://netty.io/wiki/related-projects.html">https://netty.io/wiki/related-projects.html</a> 。</p>
<h2 id="介绍一下Netty的核心组件？"><a href="#介绍一下Netty的核心组件？" class="headerlink" title="介绍一下Netty的核心组件？"></a>介绍一下Netty的核心组件？</h2><p>👨‍💻<strong>面试官</strong> ：Netty 核心组件有哪些？分别有什么作用？</p>
<p>🙋 <strong>我</strong> ：表面上，嘴上开始说起 Netty 的核心组件有哪些，实则，内心已经开始 mmp 了，深度怀疑这面试官是存心搞我啊！</p>
<p>简单介绍 Netty 最核心的一些组件（_对于每一个组件这里不详细介绍_）。通过下面这张图你可以将我提到的这些 Netty 核心组件串联起来。</p>
<p><img src="http://image.icool8.cn/blog/20201206/sUhGDhjkOhHQ.png?imageslim" alt="mark"></p>
<h3 id="Bytebuf（字节容器）"><a href="#Bytebuf（字节容器）" class="headerlink" title="Bytebuf（字节容器）"></a>Bytebuf（字节容器）</h3><p><strong>网络通信最终都是通过字节流进行传输的。 ByteBuf 就是 Netty 提供的一个字节容器，其内部是一个字节数组。</strong> 当我们通过 Netty 传输数据的时候，就是通过 <code>ByteBuf</code> 进行的。</p>
<p>我们可以将 <code>ByteBuf</code> 看作是 Netty 对 Java NIO 提供了 <code>ByteBuffer</code> 字节容器的封装和抽象。</p>
<p>有很多小伙伴可能就要问了 ： <strong>为什么不直接使用 Java NIO 提供的 ByteBuffer 呢？</strong></p>
<p>因为 <code>ByteBuffer</code> 这个类使用起来过于复杂和繁琐。</p>
<h3 id="Bootstrap-和-ServerBootstrap（启动引导类）"><a href="#Bootstrap-和-ServerBootstrap（启动引导类）" class="headerlink" title="Bootstrap 和 ServerBootstrap（启动引导类）"></a>Bootstrap 和 ServerBootstrap（启动引导类）</h3><p><strong>Bootstrap 是客户端的启动引导类/辅助类</strong>，具体使用方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建客户端启动引导/辅助类：Bootstrap</span></span><br><span class="line"></span><br><span class="line">    Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定线程模型</span></span><br><span class="line"></span><br><span class="line">    b.group(group).</span><br><span class="line"></span><br><span class="line">            ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试建立连接</span></span><br><span class="line"></span><br><span class="line">    ChannelFuture f = b.connect(host, port).sync();</span><br><span class="line"></span><br><span class="line">    f.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优雅关闭相关线程组资源</span></span><br><span class="line"></span><br><span class="line">    group.shutdownGracefully();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ServerBootstrap 客户端的启动引导类/辅助类</strong>，具体使用方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 1.bossGroup 用于接收连接，workerGroup 用于具体的处理</span></span><br><span class="line"></span><br><span class="line">    EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.创建服务端启动引导/辅助类：ServerBootstrap</span></span><br><span class="line"></span><br><span class="line">        ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.给引导类配置两大线程组,确定了线程模型</span></span><br><span class="line"></span><br><span class="line">        b.group(bossGroup, workerGroup).</span><br><span class="line"></span><br><span class="line">               ......</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.绑定端口</span></span><br><span class="line"></span><br><span class="line">        ChannelFuture f = b.bind(port).sync();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待连接关闭</span></span><br><span class="line"></span><br><span class="line">        f.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7.优雅关闭相关线程组资源</span></span><br><span class="line"></span><br><span class="line">        bossGroup.shutdownGracefully();</span><br><span class="line"></span><br><span class="line">        workerGroup.shutdownGracefully();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的示例中，我们可以看出：</p>
<ol>
<li><code>Bootstrap</code> 通常使用 <code>connet()</code> 方法连接到远程的主机和端口，作为一个 Netty TCP 协议通信中的客户端。另外，<code>Bootstrap</code> 也可以通过 <code>bind()</code> 方法绑定本地的一个端口，作为 UDP 协议通信中的一端。</li>
<li><code>ServerBootstrap</code>通常使用 <code>bind()</code> 方法绑定本地的端口上，然后等待客户端的连接。</li>
<li><code>Bootstrap</code> 只需要配置一个线程组— <code>EventLoopGroup</code> ,而 <code>ServerBootstrap</code>需要配置两个线程组— <code>EventLoopGroup</code> ，一个用于接收连接，一个用于具体的 IO 处理。</li>
</ol>
<h3 id="Channel（网络操作抽象类）"><a href="#Channel（网络操作抽象类）" class="headerlink" title="Channel（网络操作抽象类）"></a>Channel（网络操作抽象类）</h3><p><code>Channel</code> 接口是 Netty 对网络操作抽象类。通过 <code>Channel</code> 我们可以进行 I/O 操作。</p>
<p>一旦客户端成功连接服务端，就会新建一个 <code>Channel</code> 同该用户端进行绑定，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  通过 Bootstrap 的 connect 方法连接到服务端</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Channel <span class="title">doConnect</span><span class="params">(InetSocketAddress inetSocketAddress)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     CompletableFuture&lt;Channel&gt; completableFuture = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line"></span><br><span class="line">     bootstrap.connect(inetSocketAddress).addListener((ChannelFutureListener) future -&gt; &#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line"></span><br><span class="line">             completableFuture.complete(future.channel());</span><br><span class="line"></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     &#125;);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> completableFuture.get();</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>比较常用的<code>Channel</code>接口实现类是 ：</p>
<ul>
<li><code>NioServerSocketChannel</code>（服务端）</li>
<li><code>NioSocketChannel</code>（客户端）</li>
</ul>
<p>这两个 <code>Channel</code> 可以和 BIO 编程模型中的<code>ServerSocket</code>以及<code>Socket</code>两个概念对应上。</p>
<h3 id="EventLoop（事件循环）"><a href="#EventLoop（事件循环）" class="headerlink" title="EventLoop（事件循环）"></a>EventLoop（事件循环）</h3><h4 id="EventLoop-介绍"><a href="#EventLoop-介绍" class="headerlink" title="EventLoop 介绍"></a>EventLoop 介绍</h4><p>这么说吧！<code>EventLoop</code>（事件循环）接口可以说是 Netty 中最核心的概念了！</p>
<p>《Netty 实战》这本书是这样介绍它的：</p>
<blockquote>
<p><code>EventLoop</code> 定义了 Netty 的核心抽象，用于处理连接的生命周期中所发生的事件。</p>
</blockquote>
<p>是不是很难理解？说实话，我学习 Netty 的时候看到这句话是没太能理解的。</p>
<p>说白了，<strong>EventLoop 的主要作用实际就是责监听网络事件并调用事件处理器进行相关 I/O 操作（读写）的处理。</strong></p>
<h4 id="Channel-和-EventLoop-的关系"><a href="#Channel-和-EventLoop-的关系" class="headerlink" title="Channel 和 EventLoop 的关系"></a>Channel 和 EventLoop 的关系</h4><p>那 <code>Channel</code> 和 <code>EventLoop</code> 直接有啥联系呢？</p>
<p><strong>Channel 为 Netty 网络操作(读写等操作)抽象类，EventLoop 负责处理注册到其上的Channel 的 I/O 操作，两者配合进行 I/O 操作。</strong></p>
<h4 id="EventloopGroup-和-EventLoop-的关系"><a href="#EventloopGroup-和-EventLoop-的关系" class="headerlink" title="EventloopGroup 和 EventLoop 的关系"></a>EventloopGroup 和 EventLoop 的关系</h4><p><code>EventLoopGroup</code> 包含多个 <code>EventLoop</code>（每一个 <code>EventLoop</code> 通常内部包含一个线程），它管理着所有的 <code>EventLoop</code> 的生命周期。</p>
<p>并且，<strong>EventLoop 处理的 I/O 事件都将在它专有的 Thread 上被处理，即 Thread 和 EventLoop 属于 1 : 1 的关系，从而保证线程安全。</strong></p>
<p>下图是 Netty <strong>NIO</strong> 模型对应的 <code>EventLoop</code> 模型。通过这个图应该可以将<code>EventloopGroup</code>、<code>EventLoop</code>、 <code>Channel</code>三者联系起来。</p>
<p><img src="http://image.icool8.cn/blog/20201206/Iip9Gbz8o2Of.png?imageslim" alt="mark"></p>
<h3 id="ChannelHandler（消息处理器）-和-ChannelPipeline（ChannelHandler-对象链表）"><a href="#ChannelHandler（消息处理器）-和-ChannelPipeline（ChannelHandler-对象链表）" class="headerlink" title="ChannelHandler（消息处理器） 和 ChannelPipeline（ChannelHandler 对象链表）"></a>ChannelHandler（消息处理器） 和 ChannelPipeline（ChannelHandler 对象链表）</h3><p>下面这段代码使用过 Netty 的小伙伴应该不会陌生，我们指定了序列化编解码器以及自定义的 <code>ChannelHandler</code> 处理消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">b.group(eventLoopGroup)</span><br><span class="line"></span><br><span class="line">        .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> NettyKryoDecoder(kryoSerializer, RpcResponse.class));</span><br><span class="line"></span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> NettyKryoEncoder(kryoSerializer, RpcRequest.class));</span><br><span class="line"></span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> KryoClientHandler());</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p><strong>ChannelHandler 是消息的具体处理器，主要负责处理客户端/服务端接收和发送的数据。</strong></p>
<p>当 <code>Channel</code> 被创建时，它会被自动地分配到它专属的 <code>ChannelPipeline</code>。 一个<code>Channel</code>包含一个 <code>ChannelPipeline</code>。 <code>ChannelPipeline</code> 为 <code>ChannelHandler</code> 的链，一个 pipeline 上可以有多个 <code>ChannelHandler</code>。</p>
<p>我们可以在 <code>ChannelPipeline</code> 上通过 <code>addLast()</code> 方法添加一个或者多个<code>ChannelHandler</code> （_一个数据或者事件可能会被多个 Handler 处理_） 。当一个 <code>ChannelHandler</code> 处理完之后就将数据交给下一个 <code>ChannelHandler</code> 。</p>
<p>当 <code>ChannelHandler</code> 被添加到的 <code>ChannelPipeline</code> 它得到一个 <code>ChannelHandlerContext</code>，它代表一个 <code>ChannelHandler</code> 和 <code>ChannelPipeline</code> 之间的“绑定”。 <code>ChannelPipeline</code> 通过 <code>ChannelHandlerContext</code>来间接管理 <code>ChannelHandler</code> 。</p>
<p><img src="http://image.icool8.cn/blog/20201206/7ApunzRPXSz7.png?imageslim" alt="mark"></p>
<h3 id="ChannelFuture（操作执行结果）"><a href="#ChannelFuture（操作执行结果）" class="headerlink" title="ChannelFuture（操作执行结果）"></a>ChannelFuture（操作执行结果）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface ChannelFuture extends Future&lt;Void&gt; &#123;</span><br><span class="line">    Channel channel();</span><br><span class="line"></span><br><span class="line">    ChannelFuture addListener(GenericFutureListener&lt;? extends Future&lt;? super Void&gt;&gt; var1);</span><br><span class="line">     ......</span><br><span class="line"></span><br><span class="line">    ChannelFuture sync() throws InterruptedException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Netty 是异步非阻塞的，所有的 I/O 操作都为异步的。</p>
<p>因此，我们不能立刻得到操作是否执行成功，但是，你可以通过 <code>ChannelFuture</code> 接口的 <code>addListener()</code> 方法注册一个 <code>ChannelFutureListener</code>，当操作执行成功或者失败时，监听就会自动触发返回结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ChannelFuture f = b.connect(host, port).addListener(future -&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;连接成功!&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;连接失败!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).sync();</span><br></pre></td></tr></table></figure>
<p>并且，你还可以通过<code>ChannelFuture</code> 的 <code>channel()</code> 方法获取连接相关联的<code>Channel</code> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Channel channel = f.channel();</span><br></pre></td></tr></table></figure>
<p>另外，我们还可以通过 <code>ChannelFuture</code> 接口的 <code>sync()</code>方法让异步的操作编程同步的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bind()是异步的，但是，你可以通过 `sync()`方法将其变为同步。</span></span><br><span class="line"></span><br><span class="line">ChannelFuture f = b.bind(port).sync();</span><br></pre></td></tr></table></figure>
<h2 id="Bootstrap-和-ServerBootstrap-了解么？"><a href="#Bootstrap-和-ServerBootstrap-了解么？" class="headerlink" title="Bootstrap 和 ServerBootstrap 了解么？"></a>Bootstrap 和 ServerBootstrap 了解么？</h2><p>👨‍💻<strong>面试官</strong> ：你再说说自己对 <code>Bootstrap</code> 和 <code>ServerBootstrap</code> 的了解吧！</p>
<p>🙋 <strong>我</strong> ：</p>
<p><code>Bootstrap</code> 是客户端的启动引导类/辅助类，具体使用方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建客户端启动引导/辅助类：Bootstrap</span></span><br><span class="line"></span><br><span class="line">    Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定线程模型</span></span><br><span class="line"></span><br><span class="line">    b.group(group).</span><br><span class="line"></span><br><span class="line">            ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试建立连接</span></span><br><span class="line"></span><br><span class="line">    ChannelFuture f = b.connect(host, port).sync();</span><br><span class="line"></span><br><span class="line">    f.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优雅关闭相关线程组资源</span></span><br><span class="line"></span><br><span class="line">    group.shutdownGracefully();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ServerBootstrap</code> 客户端的启动引导类/辅助类，具体使用方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 1.bossGroup 用于接收连接，workerGroup 用于具体的处理</span></span><br><span class="line"></span><br><span class="line">    EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.创建服务端启动引导/辅助类：ServerBootstrap</span></span><br><span class="line"></span><br><span class="line">        ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.给引导类配置两大线程组,确定了线程模型</span></span><br><span class="line"></span><br><span class="line">        b.group(bossGroup, workerGroup).</span><br><span class="line"></span><br><span class="line">               ......</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.绑定端口</span></span><br><span class="line"></span><br><span class="line">        ChannelFuture f = b.bind(port).sync();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待连接关闭</span></span><br><span class="line"></span><br><span class="line">        f.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7.优雅关闭相关线程组资源</span></span><br><span class="line"></span><br><span class="line">        bossGroup.shutdownGracefully();</span><br><span class="line"></span><br><span class="line">        workerGroup.shutdownGracefully();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的示例中，我们可以看出：</p>
<ol>
<li><code>Bootstrap</code> 通常使用 <code>connet()</code> 方法连接到远程的主机和端口，作为一个 Netty TCP 协议通信中的客户端。另外，<code>Bootstrap</code> 也可以通过 <code>bind()</code> 方法绑定本地的一个端口，作为 UDP 协议通信中的一端。</li>
<li><code>ServerBootstrap</code>通常使用 <code>bind()</code> 方法绑定本地的端口上，然后等待客户端的连接。</li>
<li><code>Bootstrap</code> 只需要配置一个线程组— <code>EventLoopGroup</code> ,而 <code>ServerBootstrap</code>需要配置两个线程组— <code>EventLoopGroup</code> ，一个用于接收连接，一个用于具体的处理。</li>
</ol>
<h2 id="NioEventLoopGroup-默认的构造函数会起多少线程？"><a href="#NioEventLoopGroup-默认的构造函数会起多少线程？" class="headerlink" title="NioEventLoopGroup 默认的构造函数会起多少线程？"></a>NioEventLoopGroup 默认的构造函数会起多少线程？</h2><p>👨‍💻<strong>面试官</strong> ：看过 Netty 的源码了么？<code>NioEventLoopGroup</code> 默认的构造函数会起多少线程呢？</p>
<p>🙋 <strong>我</strong> ：嗯嗯！看过部分。</p>
<p>回顾我们在上面写的服务器端的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.bossGroup 用于接收连接，workerGroup 用于具体的处理</span></span><br><span class="line"></span><br><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br></pre></td></tr></table></figure>
<p>为了搞清楚<code>NioEventLoopGroup</code> 默认的构造函数 到底创建了多少个线程，我们来看一下它的源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 无参构造函数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * nThreads:0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用下一个构造方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Executor：null</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//继续调用下一个构造方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>(nThreads, (Executor) <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//中间省略部分构造函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * RejectedExecutionHandler（）：RejectedExecutionHandlers.reject()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, <span class="keyword">final</span> SelectorProvider selectorProvider,<span class="keyword">final</span> SelectStrategyFactory selectStrategyFactory)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//开始调用父类的构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>(nThreads, executor, selectorProvider, selectStrategyFactory, RejectedExecutionHandlers.reject());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一直向下走下去的话，你会发现在 <code>MultithreadEventLoopGroup</code> 类中有相关的指定线程数的代码，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从1，系统属性，CPU核心数*2 这三个值中取出一个最大的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以得出 DEFAULT_EVENT_LOOP_THREADS 的值为CPU核心数*2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_EVENT_LOOP_THREADS = Math.max(<span class="number">1</span>, SystemPropertyUtil.getInt(<span class="string">&quot;io.netty.eventLoopThreads&quot;</span>, NettyRuntime.availableProcessors() * <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 被调用的父类构造函数，NioEventLoopGroup 默认的构造函数会起多少线程的秘密所在</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当指定的线程数nThreads为0时，使用默认的线程数DEFAULT_EVENT_LOOP_THREADS</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory, Object... args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>(nThreads == <span class="number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, threadFactory, args);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>综上，我们发现 <code>NioEventLoopGroup</code> 默认的构造函数实际会起的线程数为 <strong>CPU核心数*2</strong>。</p>
<p>另外，如果你继续深入下去看构造函数的话，你会发现每个<code>NioEventLoopGroup</code>对象内部都会分配一组<code>NioEventLoop</code>，其大小是 <code>nThreads</code>, 这样就构成了一个线程池， 一个<code>NIOEventLoop</code> 和一个线程相对应，这和我们上面说的 <code>EventloopGroup</code> 和 <code>EventLoop</code>关系这部分内容相对应。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Jia Xufeng</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://icool8.cn/2018/10/01/Blog/java/netty/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B9%8B%20Netty%EF%BC%88%E4%B8%8A%EF%BC%89/">https://icool8.cn/2018/10/01/Blog/java/netty/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B9%8B%20Netty%EF%BC%88%E4%B8%8A%EF%BC%89/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/NIO/">NIO</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="http://image.icool8.cn/bolg/20210107114718.png"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="http://image.icool8.cn/bolg/20210107114632.png"><div class="post-qr-code__desc">微信打赏</div></div></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/10/02/Blog/java/netty/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B9%8B%20Netty%EF%BC%88%E4%B8%8B%EF%BC%89/"><i class="fa fa-chevron-left">  </i><span>常见问题之 Netty（下）</span></a></div><div class="next-post pull-right"><a href="/2018/09/23/Blog/Elasticsearch/Elasticsearch%E7%9A%84%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B/"><span>Elasticsearch的查询过程</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(http://image.icool8.cn/bolg/20210107113114.png)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By Jia Xufeng</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>